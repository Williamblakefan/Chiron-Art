<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chiron - Public Domain Art Discovery</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Playfair+Display:wght@400;500;600&display=swap" rel="stylesheet">
    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0b;
            --bg-secondary: #141416;
            --bg-tertiary: #1c1c1f;
            --bg-card: #18181b;
            --text-primary: #fafafa;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --accent: #c9a227;
            --accent-hover: #d4af37;
            --border: #27272a;
            --border-light: #3f3f46;
            --heart-active: #ef4444;
            --shadow: rgba(0, 0, 0, 0.5);
            --transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        :root.light {
            --bg-primary: #fafafa;
            --bg-secondary: #f4f4f5;
            --bg-tertiary: #e4e4e7;
            --bg-card: #ffffff;
            --text-primary: #18181b;
            --text-secondary: #52525b;
            --text-muted: #71717a;
            --accent: #b8960f;
            --accent-hover: #9a7d0a;
            --border: #e4e4e7;
            --border-light: #d4d4d8;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        html {
            height: 100%;
            overflow-y: scroll;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            transition: background var(--transition), color var(--transition);
            -webkit-overflow-scrolling: touch;
        }

        /* Header */
        header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        .header-content {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        /* Center nav absolutely on desktop */
        @media (min-width: 769px) {
            .header-content nav {
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
            }
        }

        .logo-container {
            display: flex;
            flex-direction: column;
        }

        .logo {
            font-family: 'Playfair Display', serif;
            font-size: 1.75rem;
            font-weight: 500;
            letter-spacing: 0.02em;
            color: var(--text-primary);
        }

        .logo span {
            color: var(--accent);
        }

        .logo-subtitle {
            font-family: 'Playfair Display', serif;
            font-size: 0.7rem;
            font-style: italic;
            color: var(--text-muted);
            letter-spacing: 0.05em;
            margin-top: -2px;
        }

        /* Navigation Tabs */
        nav {
            display: flex;
            gap: 0.5rem;
        }

        .tab-btn {
            background: transparent;
            border: none;
            padding: 0.625rem 1.25rem;
            font-family: 'Inter', sans-serif;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 8px;
            transition: all var(--transition);
            position: relative;
        }

        .tab-btn:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }

        .tab-btn.active {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }

        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 2px;
            background: var(--accent);
            border-radius: 1px;
        }

        .saved-count {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            margin-left: 6px;
            font-size: 0.7rem;
            font-weight: 600;
            background: var(--accent);
            color: var(--bg-primary);
            border-radius: 9px;
        }

        /* Theme Toggle */
        .theme-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            width: 40px;
            height: 40px;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition);
        }

        .theme-toggle:hover {
            border-color: var(--border-light);
        }

        .theme-toggle svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
            transition: fill var(--transition);
        }

        .theme-toggle:hover svg {
            fill: var(--text-primary);
        }

        /* Main Content */
        main {
            padding-top: 80px;
            min-height: 100vh;
            -webkit-overflow-scrolling: touch;
        }

        .tab-content {
            display: none;
            padding: 2rem;
            max-width: 1600px;
            margin: 0 auto;
        }

        .tab-content.active {
            display: block;
        }

        /* Search Panel */
        .search-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .search-row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .search-row:last-child {
            margin-bottom: 0;
        }

        .search-input-wrapper {
            flex: 1;
            min-width: 200px;
            position: relative;
        }

        .search-input {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 0.875rem 1rem 0.875rem 2.75rem;
            font-family: 'Inter', sans-serif;
            font-size: 0.9375rem;
            color: var(--text-primary);
            transition: all var(--transition);
        }

        .search-input::placeholder {
            color: var(--text-muted);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            fill: var(--text-muted);
        }

        .filter-select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 0.875rem 2.5rem 0.875rem 1rem;
            font-family: 'Inter', sans-serif;
            font-size: 0.875rem;
            color: var(--text-primary);
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2371717a'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 20px;
            transition: all var(--transition);
            min-width: 160px;
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .search-btn {
            background: var(--accent);
            border: none;
            border-radius: 10px;
            padding: 0.875rem 2rem;
            font-family: 'Inter', sans-serif;
            font-size: 0.9375rem;
            font-weight: 500;
            color: var(--bg-primary);
            cursor: pointer;
            transition: all var(--transition);
        }

        .search-btn:hover {
            background: var(--accent-hover);
        }

        .search-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .clear-btn {
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 0.875rem 1.5rem;
            font-family: 'Inter', sans-serif;
            font-size: 0.875rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--transition);
        }

        .clear-btn:hover {
            border-color: var(--border-light);
            color: var(--text-primary);
        }

        /* Art Grid */
        .art-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
        }

        @media (min-width: 1200px) {
            .art-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        /* Tile */
        .tile {
            perspective: 1000px;
            height: 380px;
        }

        .tile-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            transform-style: preserve-3d;
            cursor: pointer;
        }

        /* Mobile touch scrolling fix - ensure all tile layers allow vertical scroll */
        .touch-device .tile,
        .touch-device .tile-inner,
        .touch-device .tile-front,
        .touch-device .tile-back,
        .touch-device .tile-image-container,
        .touch-device .tile-overlay {
            touch-action: pan-y;
        }

        .touch-device .tile {
            -webkit-user-select: none;
            user-select: none;
        }

        .tile.flipped .tile-inner {
            transform: rotateY(180deg);
        }

        .tile-front,
        .tile-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            border-radius: 12px;
            overflow: hidden;
        }

        .tile-front {
            background: var(--bg-card);
            border: 1px solid var(--border);
        }

        .tile-back {
            background: var(--bg-card);
            border: 1px solid var(--border);
            transform: rotateY(180deg);
            display: flex;
            flex-direction: column;
        }

        /* Tile Front */
        .tile-image-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .tile-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.4s ease;
        }

        /* Mobile: prevent image from capturing touch events */
        .touch-device .tile-image {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            pointer-events: none;
        }

        .no-touch .tile:hover .tile-image {
            transform: scale(1.03);
        }

        .tile-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 1.5rem 1rem 1rem;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            opacity: 0;
            transition: opacity var(--transition);
        }

        .no-touch .tile:hover .tile-overlay {
            opacity: 1;
        }

        .tile-title-preview {
            font-family: 'Playfair Display', serif;
            font-size: 1rem;
            font-weight: 500;
            color: #fff;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .tile-artist-preview {
            font-size: 0.8125rem;
            color: rgba(255,255,255,0.7);
            margin-top: 0.25rem;
        }

        /* Tile Action Buttons */
        .tile-actions {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 10;
        }

        .tile-action-btn {
            width: 36px;
            height: 36px;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all var(--transition);
        }

        .no-touch .tile:hover .tile-action-btn,
        .save-btn.saved {
            opacity: 1;
        }

        .tile-action-btn svg {
            width: 18px;
            height: 18px;
            fill: transparent;
            stroke: #fff;
            stroke-width: 2;
            transition: all var(--transition);
        }

        .save-btn.saved svg {
            fill: var(--heart-active);
            stroke: var(--heart-active);
        }

        .tile-action-btn:hover {
            transform: scale(1.1);
            background: rgba(0,0,0,0.7);
        }

        .download-btn svg {
            fill: none;
            stroke: #fff;
            stroke-width: 2;
        }

        .download-btn:hover svg {
            stroke: var(--accent);
        }

        .download-btn.downloading {
            pointer-events: none;
        }

        .download-btn.downloading svg {
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Source Badge - Clickable Link */
        .source-badge {
            position: absolute;
            top: 0.75rem;
            left: 0.75rem;
            padding: 0.25rem 0.625rem;
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: #fff;
            border-radius: 4px;
            opacity: 0;
            transition: opacity var(--transition), background var(--transition);
            text-decoration: none;
            cursor: pointer;
            z-index: 5;
        }

        .source-badge:hover {
            background: var(--accent);
            color: #000;
        }

        .no-touch .tile:hover .source-badge,
        .no-touch .expanded-image-container:hover .source-badge {
            opacity: 1;
        }

        /* Fix source badge in expanded view - reset line-height that container sets to 0 */
        .expanded-image-container .source-badge {
            line-height: normal;
        }

        /* Tile Back - Placard */
        .placard {
            padding: 1.25rem;
            overflow-y: auto;
            height: 100%;
            scrollbar-width: thin;
            scrollbar-color: var(--border) var(--bg-secondary);
        }

        .placard::-webkit-scrollbar {
            width: 8px;
        }

        .placard::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .placard::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        .placard::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        .placard-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.125rem;
            font-weight: 500;
            line-height: 1.3;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .placard-artist {
            font-size: 0.9375rem;
            color: var(--accent);
            margin-bottom: 0.125rem;
        }

        .placard-artist-dates {
            font-size: 0.8125rem;
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .placard-divider {
            height: 1px;
            background: var(--border);
            margin: 0.875rem 0;
        }

        .placard-field {
            margin-bottom: 0.625rem;
        }

        .placard-label {
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
            margin-bottom: 0.125rem;
        }

        .placard-value {
            font-size: 0.8125rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .placard-description {
            font-size: 0.8125rem;
            color: var(--text-secondary);
            line-height: 1.5;
            font-style: italic;
        }

        .placard-source {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-decoration: none;
            transition: all var(--transition);
            margin-top: 0.5rem;
        }

        .placard-source:hover {
            background: var(--border);
            color: var(--text-primary);
        }

        .placard-source svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }

        /* Loading States */
        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem 2rem;
            color: var(--text-muted);
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 1rem;
            font-size: 0.875rem;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem 2rem;
            text-align: center;
        }

        .empty-icon {
            width: 64px;
            height: 64px;
            fill: var(--text-muted);
            margin-bottom: 1.5rem;
            opacity: 0.5;
        }

        .empty-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.5rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .empty-text {
            font-size: 0.9375rem;
            color: var(--text-muted);
            max-width: 400px;
        }

        /* Scroll Loading Indicator - Enhanced */
        .scroll-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2.5rem 2rem;
            gap: 1rem;
            color: var(--text-secondary);
        }

        .scroll-loading-phrase {
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            font-style: italic;
            color: var(--text-primary);
            opacity: 0.9;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .scroll-loading-dots {
            display: inline-flex;
            gap: 2px;
        }

        .scroll-loading-dots span {
            width: 4px;
            height: 4px;
            background: var(--accent);
            border-radius: 50%;
            animation: loading-dot 1.4s ease-in-out infinite;
        }

        .scroll-loading-dots span:nth-child(1) { animation-delay: 0s; }
        .scroll-loading-dots span:nth-child(2) { animation-delay: 0.2s; }
        .scroll-loading-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes loading-dot {
            0%, 80%, 100% {
                opacity: 0.3;
                transform: scale(0.8);
            }
            40% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        .scroll-loading-bar-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            width: 100%;
            max-width: 300px;
        }

        .scroll-loading-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .scroll-loading-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-hover));
            border-radius: 2px;
            transition: width 0.3s ease;
            position: relative;
        }

        .scroll-loading-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: loading-shimmer 1.5s ease-in-out infinite;
        }

        @keyframes loading-shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .scroll-loading-bar-glow {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 8px;
            height: 8px;
            background: var(--accent);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent), 0 0 20px var(--accent), 0 0 30px var(--accent);
            animation: loading-glow 1s ease-in-out infinite alternate;
        }

        @keyframes loading-glow {
            0% {
                opacity: 0.6;
                box-shadow: 0 0 5px var(--accent), 0 0 10px var(--accent);
            }
            100% {
                opacity: 1;
                box-shadow: 0 0 10px var(--accent), 0 0 20px var(--accent), 0 0 30px var(--accent);
            }
        }

        .scroll-loading-count {
            font-size: 0.75rem;
            color: var(--text-muted);
            white-space: nowrap;
        }

        /* Buffer Indicator */
        .buffer-indicator {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.5rem 0.75rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            opacity: 0.7;
            transition: opacity var(--transition);
            z-index: 50;
        }

        .buffer-indicator:hover {
            opacity: 1;
        }

        .buffer-indicator .buffer-bar {
            width: 60px;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
        }

        .buffer-indicator .buffer-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .buffer-indicator.fetching .buffer-fill {
            animation: buffer-pulse 1s ease-in-out infinite;
        }

        @keyframes buffer-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Error Message */
        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 10px;
            padding: 1rem 1.5rem;
            color: #fca5a5;
            font-size: 0.875rem;
            margin-bottom: 1.5rem;
        }

        /* Status Text */
        .status-text {
            font-size: 0.8125rem;
            color: var(--text-muted);
            margin-bottom: 1.5rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header-content {
                padding: 0.75rem 1rem;
                display: grid;
                grid-template-columns: auto 1fr auto auto;
                grid-template-rows: auto auto;
                gap: 1rem 0.5rem;
                align-items: center;
            }

            .header-left {
                display: contents;
            }

            .logo-container {
                grid-column: 1;
                grid-row: 1;
            }

            .header-left .auth-buttons {
                grid-column: 3;
                grid-row: 1;
                justify-content: flex-end;
                gap: 0.5rem;
            }

            .theme-toggle {
                grid-column: 4;
                grid-row: 1;
            }

            nav {
                grid-column: 1 / -1;
                grid-row: 2;
                justify-content: center;
            }

            .logo {
                font-size: 1.5rem;
            }

            .logo-subtitle {
                display: none;
            }

            .auth-btn {
                padding: 0.4rem 0.75rem;
                font-size: 0.75rem;
            }

            .tab-btn {
                padding: 0.5rem 0.875rem;
                font-size: 0.8125rem;
            }

            .tab-content {
                padding: 1rem;
            }

            .search-panel {
                padding: 1rem;
            }

            .art-grid {
                grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
                gap: 1rem;
            }

            .tile {
                height: 280px;
            }

            .placard {
                padding: 1rem;
            }

            .placard-title {
                font-size: 1rem;
            }

        }

        /* Mobile expanded view: X button on left with padding above image */
        .touch-device .expanded-close-btn {
            left: 1rem;
            right: auto;
            top: 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
        }

        .touch-device .expanded-close-btn svg {
            stroke: var(--text-primary);
        }

        .touch-device .expanded-overlay {
            padding-top: 4rem;
        }

        /* Make swipe indicator more visible on touch devices */
        .touch-device .swipe-indicator {
            opacity: 1;
        }

        /* Skeleton Loading */
        .skeleton {
            background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s ease-in-out infinite;
            border-radius: 12px;
        }

        @keyframes skeleton-loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .skeleton-tile {
            height: 380px;
        }

        @media (max-width: 768px) {
            .skeleton-tile {
                height: 280px;
            }
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 0.875rem 1.5rem;
            font-size: 0.875rem;
            color: var(--text-primary);
            box-shadow: 0 10px 40px var(--shadow);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* ===== Expanded View ===== */
        /* Mobile: Overlay style */
        .expanded-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            display: none;
            overflow-y: auto;
            padding: 1rem;
            scrollbar-width: thin;
            scrollbar-color: var(--border) var(--bg-secondary);
        }

        .expanded-overlay::-webkit-scrollbar {
            width: 8px;
        }

        .expanded-overlay::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .expanded-overlay::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        .expanded-overlay::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        .expanded-overlay.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .expanded-overlay.active .expanded-container {
            animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .expanded-close-btn {
            position: fixed;
            top: 1rem;
            right: 1rem;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 210;
            transition: all var(--transition);
        }

        .expanded-close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .expanded-close-btn svg {
            width: 24px;
            height: 24px;
            stroke: #fff;
            stroke-width: 2;
        }

        .expanded-container {
            max-width: 900px;
            margin: 0 auto;
            padding-top: 3rem;
        }

        /* Mobile: stack vertically */
        .expanded-left-panel {
            display: block;
        }

        .expanded-right-grid {
            padding: 1rem;
            margin-top: 1rem;
        }

        .expanded-right-grid .art-grid {
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        }

        /* Desktop: Full-page side-by-side layout */
        @media (min-width: 1024px) {
            .expanded-overlay {
                background: var(--bg-primary);
                padding: 0;
                overflow: hidden;
            }

            .expanded-overlay.active {
                animation: none;
            }

            .expanded-close-btn {
                position: fixed;
                top: 1.5rem;
                left: 1.5rem;
                right: auto;
                background: var(--bg-secondary);
                border: 1px solid var(--border);
            }

            .expanded-close-btn:hover {
                background: var(--bg-card);
                border-color: var(--accent);
            }

            .expanded-close-btn svg {
                stroke: var(--text-primary);
            }

            .expanded-container {
                max-width: none;
                margin: 0;
                padding: 0;
                display: flex;
                gap: 0;
                height: 100vh;
            }

            .expanded-left-panel {
                flex-shrink: 0;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                padding: 2rem;
                padding-top: 5rem;
                padding-left: 5rem;
                padding-right: 2rem;
                background: var(--bg-secondary);
                overflow-y: auto;
                max-width: 65%;
            }

            .expanded-content {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .expanded-image-container {
                background: transparent;
                border-radius: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .expanded-image {
                max-height: 80vh;
                max-width: 100%;
                width: auto;
                height: auto;
                object-fit: contain;
                border-radius: 12px;
            }

            .expanded-details {
                margin-top: 1.5rem;
                max-width: 600px;
                width: 100%;
            }

            .expanded-right-grid {
                flex-grow: 1;
                background: var(--bg-primary);
                border-left: 1px solid var(--border);
                overflow-y: auto;
                overflow-x: hidden;
                padding: 1.5rem;
                display: flex;
                flex-direction: column;
                min-width: 350px;
            }

            .expanded-right-grid .grid-title {
                font-size: 0.875rem;
                color: var(--text-muted);
                margin-bottom: 1rem;
                text-transform: uppercase;
                letter-spacing: 0.05em;
                flex-shrink: 0;
            }

            .expanded-right-grid .art-grid {
                flex: 1;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 1rem;
                align-content: start;
            }

            .expanded-right-grid .tile {
                height: auto;
                aspect-ratio: 1;
            }

            .expanded-right-grid .loading-indicator {
                padding: 1rem;
            }
        }

        @media (min-width: 1400px) {
            .expanded-left-panel {
                max-width: 60%;
            }

            .expanded-right-grid {
                min-width: 400px;
            }

            .expanded-right-grid .art-grid {
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            }
        }

        @media (min-width: 1800px) {
            .expanded-left-panel {
                max-width: 55%;
            }

            .expanded-right-grid {
                min-width: 500px;
            }

            .expanded-right-grid .art-grid {
                grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            }
        }

        /* Expanded Content wrapper */
        .expanded-content {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }

        /* Download button in expanded view */
        .expanded-download-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition);
            z-index: 5;
        }

        /* Desktop: hide buttons by default, show on hover */
        .no-touch .expanded-download-btn {
            opacity: 0;
        }

        .no-touch .expanded-image-container:hover .expanded-download-btn {
            opacity: 1;
        }

        /* Mobile: always show buttons */
        .touch .expanded-download-btn {
            opacity: 1;
        }

        .expanded-download-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.1);
        }

        .expanded-download-btn svg {
            width: 22px;
            height: 22px;
            fill: none;
            stroke: #fff;
            stroke-width: 2;
        }

        .expanded-download-btn.downloading svg {
            animation: pulse 1s ease-in-out infinite;
        }

        .expanded-save-btn svg {
            fill: none;
            stroke: #fff;
            stroke-width: 2;
        }

        .expanded-save-btn.saved svg {
            fill: var(--heart-active);
            stroke: var(--heart-active);
        }

        .expanded-image-container {
            position: relative;
            user-select: none;
            border-radius: 12px;
            overflow: hidden;
            line-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .expanded-image {
            max-width: 100%;
            max-height: 60vh;
            width: auto;
            height: auto;
            object-fit: contain;
            display: block;
            border-radius: 12px;
        }

        /* Expanded Details - Below image metadata */
        .expanded-details {
            padding: 1.5rem;
            background: var(--bg-card);
            border-radius: 12px;
            margin-top: 1rem;
            overflow: hidden;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .expanded-details .placard-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.5rem;
            font-weight: 500;
            color: var(--text-primary);
            line-height: 1.3;
            margin-bottom: 0.5rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .expanded-details .placard-artist {
            font-size: 1.125rem;
            color: #f0c14b;
            margin-bottom: 0.5rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .expanded-details .placard-artist-dates {
            font-size: 0.875rem;
            color: var(--text-muted);
            margin-bottom: 1rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .expanded-details .placard-divider {
            height: 1px;
            background: var(--border);
            margin: 1rem 0;
        }

        .expanded-details .placard-field {
            margin-bottom: 0.75rem;
        }

        .expanded-details .placard-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }

        .expanded-details .placard-value {
            font-size: 0.9375rem;
            color: var(--text-primary);
            line-height: 1.4;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .expanded-details .placard-description {
            font-size: 0.9375rem;
            color: var(--text-secondary);
            line-height: 1.6;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .expanded-details .placard-source {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
            padding: 0.625rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-decoration: none;
            transition: all var(--transition);
        }

        .expanded-details .placard-source:hover {
            background: var(--border);
            color: var(--text-primary);
        }

        .expanded-details .placard-source svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        /* Mobile: Hide tile overlay by default and disable touch capture */
        .touch-device .tile-overlay,
        .touch-device .tile-action-btn,
        .touch-device .source-badge {
            opacity: 0 !important;
            pointer-events: none;
        }

        /* Desktop: Show on hover (existing behavior) */
        .no-touch .tile:hover .tile-overlay,
        .no-touch .tile:hover .tile-action-btn,
        .no-touch .tile:hover .source-badge {
            opacity: 1;
        }

        /* Always show saved button if saved - and make it clickable */
        .tile .save-btn.saved {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* Mobile expanded view adjustments */
        @media (max-width: 768px) {
            .expanded-container {
                padding-top: 2rem;
            }

            .expanded-details {
                padding: 1.25rem;
            }

            .expanded-details .placard-title {
                font-size: 1.25rem;
            }

            .expanded-details .placard-artist {
                font-size: 1rem;
            }
        }

        /* Swipe indicator for mobile */
        .swipe-indicator {
            position: fixed;
            top: 0.5rem;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            z-index: 210;
        }

        .touch-device .swipe-indicator {
            display: block;
        }

        .no-touch .swipe-indicator {
            display: none;
        }

        /* ===== Modal Base Styles ===== */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 300;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background-color: var(--bg-secondary);
            border-radius: 16px;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            animation: modalIn 0.3s ease;
            position: relative;
            scrollbar-width: thin;
            scrollbar-color: var(--border) var(--bg-secondary);
        }

        .modal::-webkit-scrollbar {
            width: 8px;
        }

        .modal::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .modal::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        .modal::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        @keyframes modalIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-family: 'Playfair Display', serif;
            font-size: 1.25rem;
            font-weight: 500;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0;
            line-height: 1;
            transition: color var(--transition);
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-body {
            padding: 24px;
        }

        /* General button styles for modals */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.9375rem;
            cursor: pointer;
            transition: all var(--transition);
        }

        .btn-primary {
            background-color: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--accent-hover);
        }

        /* ===== Auth Styles ===== */
        .auth-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .auth-btn {
            height: 36px;
            min-width: 70px;
            padding: 0 14px;
            font-size: 0.8125rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .auth-btn-secondary {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }

        .auth-btn-secondary:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .auth-btn-primary {
            background-color: var(--accent);
            border: 1px solid var(--accent);
            color: white;
        }

        .auth-btn-primary:hover {
            background-color: var(--accent-hover);
            border-color: var(--accent-hover);
        }

        .auth-modal {
            max-width: 400px;
            position: relative;
        }

        .auth-modal .modal-header {
            text-align: center;
            padding: 24px 30px 15px;
            display: block;
            border-bottom: none;
        }

        .auth-modal .modal-header h2 {
            font-size: 1.5rem;
            margin: 0 auto;
            font-family: 'Playfair Display', serif;
        }

        .auth-modal .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
        }

        .auth-modal .modal-body {
            padding: 10px 30px 30px;
        }

        .auth-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            margin-bottom: 20px;
        }

        .auth-tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            color: var(--text-muted);
            border-bottom: 2px solid transparent;
            transition: all var(--transition);
            background: none;
            border-top: none;
            border-left: none;
            border-right: none;
            font-size: 0.9375rem;
        }

        .auth-tab:hover {
            color: var(--text-secondary);
        }

        .auth-tab.active {
            color: var(--text-primary);
            border-bottom-color: var(--accent);
        }

        .auth-form {
            display: none;
        }

        .auth-form.active {
            display: block;
        }

        .auth-form .form-group {
            margin-bottom: 16px;
        }

        .auth-form .form-group label {
            display: block;
            margin-bottom: 6px;
            color: var(--text-secondary);
            font-size: 0.8125rem;
        }

        .auth-form .form-group input {
            width: 100%;
            padding: 12px 14px;
            font-size: 0.9375rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            transition: border-color var(--transition);
        }

        .auth-form .form-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .password-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .password-input-wrapper input {
            padding-right: 45px;
        }

        .password-toggle {
            position: absolute;
            right: 12px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            transition: color var(--transition);
        }

        .password-toggle:hover {
            color: var(--text-primary);
        }

        .password-toggle svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .auth-form .btn {
            width: 100%;
            margin-top: 10px;
            padding: 12px 20px;
        }

        .forgot-password-link {
            text-align: center;
            margin-top: 16px;
        }

        .forgot-password-link a,
        .back-to-login a {
            color: var(--text-secondary);
            font-size: 0.8125rem;
            text-decoration: none;
            transition: color var(--transition);
        }

        .forgot-password-link a:hover,
        .back-to-login a:hover {
            color: var(--accent);
        }

        .forgot-password-text {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .back-to-login {
            text-align: center;
            margin-top: 16px;
        }

        .auth-error {
            background-color: rgba(200, 80, 80, 0.1);
            border: 1px solid rgba(200, 80, 80, 0.3);
            color: #e05050;
            padding: 10px 14px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 0.8125rem;
            display: none;
        }

        .auth-error.visible {
            display: block;
        }

        .auth-success {
            background-color: rgba(107, 142, 92, 0.1);
            border: 1px solid rgba(107, 142, 92, 0.3);
            color: #6b8e5c;
            padding: 10px 14px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 0.8125rem;
            display: none;
        }

        .auth-success.visible {
            display: block;
        }

        .auth-divider {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8125rem;
            margin: 15px 0;
        }

        .auth-link {
            color: var(--accent);
            cursor: pointer;
        }

        .auth-link:hover {
            text-decoration: underline;
        }

        /* Settings Modal */
        .settings-modal {
            max-width: 400px;
        }

        .settings-modal .modal-header {
            text-align: center;
            display: block;
            padding: 24px 30px 0;
            border-bottom: none;
        }

        .settings-modal .modal-header h2 {
            margin: 0;
            font-family: 'Playfair Display', serif;
        }

        .settings-modal .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
        }

        .settings-modal .modal-body {
            padding: 30px;
        }

        .settings-section {
            margin-bottom: 25px;
        }

        .settings-label {
            font-size: 0.8125rem;
            color: var(--text-muted);
            display: block;
            margin-bottom: 5px;
        }

        .settings-value {
            font-size: 1rem;
            color: var(--text-primary);
        }

        .settings-btn {
            width: 100%;
            padding: 12px 20px;
            margin-bottom: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all var(--transition);
            font-size: 0.9375rem;
        }

        .settings-btn-secondary {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }

        .settings-btn-secondary:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .settings-btn-danger {
            background: transparent;
            color: #e05050;
            border: 1px solid #e05050;
        }

        .settings-btn-danger:hover {
            background: rgba(224, 80, 80, 0.1);
        }

        /* Account Links */
        .account-link {
            color: var(--text-muted);
            font-size: 0.75rem;
            cursor: pointer;
            margin-left: 10px;
        }

        .account-link:hover {
            color: var(--accent);
            text-decoration: underline;
        }

        .account-link.danger:hover {
            color: #c85050;
        }

        /* Terms Checkbox */
        .terms-checkbox {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin: 15px 0;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .terms-checkbox input[type="checkbox"] {
            margin-top: 3px;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .terms-checkbox label {
            cursor: pointer;
            line-height: 1.4;
        }

        .terms-checkbox a {
            color: var(--accent);
            text-decoration: none;
        }

        .terms-checkbox a:hover {
            text-decoration: underline;
        }

        /* Confirmation Modal */
        .confirm-modal {
            max-width: 350px;
        }

        .confirm-modal .modal-body {
            padding: 20px 30px 30px;
            text-align: center;
        }

        .confirm-modal .modal-body p {
            color: var(--text-secondary);
            margin-bottom: 24px;
        }

        .confirm-modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .confirm-modal-buttons .btn {
            min-width: 80px;
        }

        /* Delete Account Modal */
        .btn-danger {
            background-color: #c85050;
            border: 1px solid #c85050;
            color: white;
        }

        .btn-danger:hover {
            background-color: #b04040;
            border-color: #b04040;
        }

        .delete-modal {
            max-width: 450px;
        }

        .delete-modal .modal-body {
            padding: 20px 30px 30px;
        }

        .delete-warning {
            background-color: rgba(200, 80, 80, 0.1);
            border: 1px solid rgba(200, 80, 80, 0.3);
            color: #c85050;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .delete-confirm-input {
            width: 100%;
            padding: 12px 14px;
            font-size: 0.95rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            margin: 15px 0;
        }

        .delete-confirm-input:focus {
            outline: none;
            border-color: #c85050;
        }

        .delete-modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Legal Modals */
        /* Legal modals should appear above auth modal */
        #privacyModal, #termsModal {
            z-index: 400;
        }

        .legal-modal {
            max-width: 700px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
        }

        .legal-modal .modal-body {
            overflow-y: auto;
            padding: 20px 30px 30px;
            flex: 1;
        }

        .legal-content {
            font-size: 0.95rem;
            line-height: 1.7;
            color: var(--text-secondary);
        }

        .legal-content h3 {
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            margin: 25px 0 10px 0;
            font-weight: normal;
        }

        .legal-content p {
            margin: 0 0 15px 0;
        }

        .legal-content ul {
            margin: 0 0 15px 0;
            padding-left: 20px;
        }

        .legal-content li {
            margin-bottom: 8px;
        }

        .legal-content .last-updated {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 20px;
        }

        /* Footer */
        .app-footer {
            text-align: center;
            padding: 30px 20px;
            margin-top: 40px;
            border-top: 1px solid var(--border);
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .app-footer a {
            color: var(--text-muted);
            text-decoration: none;
            margin: 0 15px;
        }

        .app-footer a:hover {
            color: var(--accent);
            text-decoration: underline;
        }

        .footer-divider {
            color: var(--border);
            margin: 0 5px;
        }

        /* Folder Modal */
        .folder-modal {
            max-width: 400px;
            position: relative;
        }

        .folder-modal .modal-header {
            text-align: center;
            padding: 24px 30px 15px;
            display: block;
            border-bottom: none;
        }

        .folder-modal .modal-header h2 {
            font-size: 1.3rem;
            margin: 0 auto;
            font-family: 'Playfair Display', serif;
        }

        .folder-modal .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
        }

        .folder-modal .modal-body {
            padding: 10px 30px 30px;
        }

        .folder-list {
            max-height: 250px;
            overflow-y: auto;
            margin-bottom: 16px;
            scrollbar-width: thin;
            scrollbar-color: var(--border) var(--bg-secondary);
        }

        .folder-list::-webkit-scrollbar {
            width: 8px;
        }

        .folder-list::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .folder-list::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        .folder-list::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        .folder-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            border-radius: 8px;
            transition: background var(--transition);
            gap: 12px;
        }

        .folder-item:hover {
            background: var(--bg-secondary);
        }

        .folder-item-icon {
            width: 20px;
            height: 20px;
            color: var(--accent);
            flex-shrink: 0;
        }

        .folder-item-thumb-wrapper {
            width: 40px;
            height: 40px;
            flex-shrink: 0;
            margin-right: 12px;
            position: relative;
        }

        .folder-item-thumb {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            object-fit: cover;
            background: var(--bg-tertiary);
        }

        .folder-item-placeholder {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            background: var(--bg-tertiary);
            flex-shrink: 0;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .folder-item-thumb-wrapper .folder-item-placeholder {
            margin-right: 0;
        }

        .folder-item-placeholder svg {
            width: 20px;
            height: 20px;
            color: var(--text-muted);
        }

        .folder-item-name {
            flex: 1;
            font-size: 0.9375rem;
            color: var(--text-primary);
        }

        .folder-item-count {
            font-size: 0.8125rem;
            color: var(--text-muted);
        }

        .folder-create {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }

        /* Folder Tiles for Saved Tab */
        .folder-tile {
            height: 380px;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
            background: var(--bg-card);
            border: 1px solid var(--border);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .folder-tile:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        }

        .folder-tile-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            width: 100%;
            height: calc(100% - 60px);
            gap: 2px;
            background: var(--border);
        }

        .folder-tile-thumb {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: var(--bg-tertiary);
        }

        .folder-tile-placeholder {
            width: 100%;
            height: 100%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .folder-tile-placeholder svg {
            width: 40px;
            height: 40px;
            color: var(--text-muted);
            opacity: 0.5;
        }

        .folder-tile-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 12px 16px;
            background: var(--bg-card);
            border-top: 1px solid var(--border);
        }

        .folder-tile-name {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .folder-tile-count {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        /* Back button for folder view */
        .saved-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 1.5rem;
        }

        .saved-back-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9375rem;
            cursor: pointer;
            transition: background var(--transition);
        }

        .saved-back-btn:hover {
            background: var(--bg-tertiary);
        }

        .saved-back-btn svg {
            width: 18px;
            height: 18px;
        }

        .saved-folder-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .folder-create input {
            flex: 1;
            padding: 10px 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.9375rem;
        }

        .folder-create input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .folder-create input::placeholder {
            color: var(--text-muted);
        }

        .folder-actions {
            display: flex;
            justify-content: center;
        }

        .folder-actions .btn {
            width: 100%;
        }

        .folder-empty {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 0.875rem;
        }

        @media (max-width: 768px) {
            .auth-buttons {
                gap: 8px;
            }

            .auth-btn {
                padding: 0 10px;
                font-size: 0.75rem;
                min-width: 60px;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="header-left">
                <div class="logo-container">
                    <div class="logo">Chiron<span>.</span></div>
                    <div class="logo-subtitle">  </div>
                </div>
                <div class="auth-buttons" id="authButtons">
                    <button class="auth-btn auth-btn-secondary" onclick="openAuthModal('login')">Log In</button>
                    <button class="auth-btn auth-btn-primary" onclick="openAuthModal('signup')">Sign Up</button>
                </div>
            </div>
            <nav>
                <button class="tab-btn active" data-tab="explore">Explore</button>
                <button class="tab-btn" data-tab="foryou" id="forYouTabBtn" style="display: none;">For You</button>
                <button class="tab-btn" data-tab="search">Search</button>
                <button class="tab-btn" data-tab="saved">Saved</button>
            </nav>
            <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
                <svg class="sun-icon" viewBox="0 0 24 24" style="display: none;">
                    <path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.99 4.58c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41L5.99 4.58zm12.37 12.37c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0 .39-.39.39-1.03 0-1.41l-1.06-1.06zm1.06-10.96c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06zM7.05 18.36c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06z"/>
                </svg>
                <svg class="moon-icon" viewBox="0 0 24 24">
                    <path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"/>
                </svg>
            </button>
        </div>
    </header>

    <main>
        <!-- Explore Tab -->
        <section class="tab-content active" id="exploreTab">
            <div class="art-grid" id="exploreGrid"></div>
            <div class="loading-container" id="exploreLoading" style="display: none;">
                <div class="spinner"></div>
                <div class="loading-text">Discovering masterpieces...</div>
            </div>
            <div class="scroll-loading" id="exploreScrollLoading" style="display: none;">
                <div class="scroll-loading-phrase">
                    <span id="exploreLoadingPhrase">The gallery doors are opening</span>
                    <div class="scroll-loading-dots">
                        <span></span><span></span><span></span>
                    </div>
                </div>
                <div class="scroll-loading-bar-container">
                    <div class="scroll-loading-bar">
                        <div class="scroll-loading-bar-fill" id="exploreScrollBarFill" style="width: 0%">
                            <div class="scroll-loading-bar-glow"></div>
                        </div>
                    </div>
                    <span class="scroll-loading-count"><span id="exploreScrollCount">0</span> preloaded</span>
                </div>
            </div>
        </section>

        <!-- For You Tab -->
        <section class="tab-content" id="foryouTab">
            <div class="art-grid" id="forYouGrid"></div>
            <div class="loading-container" id="forYouLoading" style="display: none;">
                <div class="spinner"></div>
                <div class="loading-text">Finding art you'll love...</div>
            </div>
            <div class="scroll-loading" id="forYouScrollLoading" style="display: none;">
                <div class="scroll-loading-phrase">
                    <span id="forYouLoadingPhrase">Curating your collection</span>
                    <div class="scroll-loading-dots">
                        <span></span><span></span><span></span>
                    </div>
                </div>
                <div class="scroll-loading-bar-container">
                    <div class="scroll-loading-bar">
                        <div class="scroll-loading-bar-fill" id="forYouScrollBarFill" style="width: 0%">
                            <div class="scroll-loading-bar-glow"></div>
                        </div>
                    </div>
                    <span class="scroll-loading-count"><span id="forYouScrollCount">0</span> preloaded</span>
                </div>
            </div>
            <!-- Empty state: Not logged in -->
            <div class="empty-state" id="forYouLoginPrompt" style="display: none;">
                <svg class="empty-icon" viewBox="0 0 24 24">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/>
                </svg>
                <h3 class="empty-title">Sign in to see personalized recommendations</h3>
                <p class="empty-text">Create an account to receive recommendations based on the works you save.</p>
                <button class="btn btn-primary" onclick="openAuthModal('signup')" style="margin-top: 1rem;">Sign Up</button>
            </div>
            <!-- Empty state: Not enough saves -->
            <div class="empty-state" id="forYouColdStart" style="display: none;">
                <svg class="empty-icon" viewBox="0 0 24 24">
                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                </svg>
                <h3 class="empty-title">Save a few more artworks</h3>
                <p class="empty-text">Save at least 3 pieces you love, then we'll find similar art for you.</p>
            </div>
            <!-- Empty state: No recommendations found -->
            <div class="empty-state" id="forYouEmpty" style="display: none;">
                <svg class="empty-icon" viewBox="0 0 24 24">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <h3 class="empty-title">No recommendations yet</h3>
                <p class="empty-text">Keep exploring and saving art you love.</p>
            </div>
        </section>

        <!-- Search Tab -->
        <section class="tab-content" id="searchTab">
            <div class="search-panel">
                <div class="search-row">
                    <div class="search-input-wrapper">
                        <svg class="search-icon" viewBox="0 0 24 24">
                            <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                        </svg>
                        <input type="text" class="search-input" id="searchInput" placeholder="Search anything . . . (try &quot;landscape&quot; or &quot;waves&quot; or &quot;portraits&quot;)">
                    </div>
                    <button class="search-btn" id="searchBtn">Search</button>
                </div>
            </div>
            <div class="status-text" id="searchStatus"></div>
            <div class="error-message" id="searchError" style="display: none;"></div>
            <div class="art-grid" id="searchGrid"></div>
            <div class="loading-container" id="searchLoading" style="display: none;">
                <div class="spinner"></div>
                <div class="loading-text">Searching collections...</div>
            </div>
            <div class="empty-state" id="searchEmpty" style="display: none;">
                <svg class="empty-icon" viewBox="0 0 24 24">
                    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                </svg>
                <h3 class="empty-title">No artworks found</h3>
                <p class="empty-text">Try adjusting your search terms or filters to discover more masterpieces.</p>
            </div>
            <div class="scroll-loading" id="searchScrollLoading" style="display: none;">
                <div class="scroll-loading-phrase">
                    <span id="searchLoadingPhrase">The gallery doors are opening</span>
                    <div class="scroll-loading-dots">
                        <span></span><span></span><span></span>
                    </div>
                </div>
                <div class="scroll-loading-bar-container">
                    <div class="scroll-loading-bar">
                        <div class="scroll-loading-bar-fill" id="searchScrollBarFill" style="width: 0%">
                            <div class="scroll-loading-bar-glow"></div>
                        </div>
                    </div>
                    <span class="scroll-loading-count"><span id="searchScrollCount">0</span> preloaded</span>
                </div>
            </div>
        </section>

        <!-- Saved Tab -->
        <section class="tab-content" id="savedTab">
            <div class="saved-header" id="savedHeader" style="display: none;">
                <button class="saved-back-btn" onclick="showSavedFolders()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 12H5M12 19l-7-7 7-7"/>
                    </svg>
                    Back
                </button>
                <span class="saved-folder-title" id="savedFolderTitle"></span>
            </div>
            <div class="art-grid" id="savedGrid"></div>
            <div class="loading-container" id="savedLoading" style="display: none;">
                <div class="spinner"></div>
                <div class="loading-text">Loading your collection...</div>
            </div>
            <div class="empty-state" id="savedEmpty" style="display: none;">
                <svg class="empty-icon" viewBox="0 0 24 24">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                </svg>
                <h3 class="empty-title">No folders yet</h3>
                <p class="empty-text">Save artworks to create your first folder.</p>
            </div>
            <div class="empty-state" id="savedLoginPrompt" style="display: none;">
                <svg class="empty-icon" viewBox="0 0 24 24">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/>
                </svg>
                <h3 class="empty-title">Sign in to see your saved artworks</h3>
                <p class="empty-text">Create an account to save artworks and access them from any device.</p>
                <button class="btn btn-primary" onclick="openAuthModal('signup')" style="margin-top: 1rem;">Sign Up</button>
            </div>
        </section>

    </main>

    <div class="toast" id="toast"></div>

    <!-- Auth Modal -->
    <div class="modal-overlay" id="authModal">
        <div class="modal auth-modal">
            <div class="modal-header">
                <h2>Welcome</h2>
                <button class="modal-close" onclick="closeAuthModal()">&times;</button>
            </div>
            <div class="auth-tabs">
                <button class="auth-tab active" onclick="switchAuthTab('login')">Log In</button>
                <button class="auth-tab" onclick="switchAuthTab('signup')">Sign Up</button>
            </div>
            <div class="modal-body">
                <div id="authError" class="auth-error"></div>
                <div id="authSuccess" class="auth-success"></div>
                <form id="loginForm" class="auth-form active" onsubmit="handleLogin(event)">
                    <div class="form-group">
                        <label for="loginEmail">Email</label>
                        <input type="email" id="loginEmail" required placeholder="your@email.com">
                    </div>
                    <div class="form-group">
                        <label for="loginPassword">Password</label>
                        <div class="password-input-wrapper">
                            <input type="password" id="loginPassword" required minlength="6" placeholder="Your password">
                            <button type="button" class="password-toggle" onclick="togglePasswordVisibility('loginPassword', this)" aria-label="Show password">
                                <svg class="eye-open" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                                <svg class="eye-closed" style="display:none" viewBox="0 0 24 24"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>
                            </button>
                        </div>
                    </div>
                    <button type="submit" class="btn btn-primary">Log In</button>
                    <div class="forgot-password-link">
                        <a href="#" onclick="showForgotPassword(); return false;">Forgot your password?</a>
                    </div>
                </form>
                <form id="forgotPasswordForm" class="auth-form" onsubmit="handleForgotPassword(event)">
                    <p class="forgot-password-text">Enter your email address and we'll send you a link to reset your password.</p>
                    <div class="form-group">
                        <label for="forgotEmail">Email</label>
                        <input type="email" id="forgotEmail" required placeholder="your@email.com">
                    </div>
                    <button type="submit" class="btn btn-primary">Send Reset Link</button>
                    <div class="back-to-login">
                        <a href="#" onclick="backToLogin(); return false;">Back to Login</a>
                    </div>
                </form>
                <form id="signupForm" class="auth-form" onsubmit="handleSignup(event)">
                    <div class="form-group">
                        <label for="signupEmail">Email</label>
                        <input type="email" id="signupEmail" required placeholder="your@email.com">
                    </div>
                    <div class="form-group">
                        <label for="signupPassword">Password</label>
                        <div class="password-input-wrapper">
                            <input type="password" id="signupPassword" required minlength="6" placeholder="At least 6 characters">
                            <button type="button" class="password-toggle" onclick="togglePasswordVisibility('signupPassword', this)" aria-label="Show password">
                                <svg class="eye-open" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                                <svg class="eye-closed" style="display:none" viewBox="0 0 24 24"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>
                            </button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="signupConfirm">Confirm Password</label>
                        <div class="password-input-wrapper">
                            <input type="password" id="signupConfirm" required minlength="6" placeholder="Confirm your password">
                            <button type="button" class="password-toggle" onclick="togglePasswordVisibility('signupConfirm', this)" aria-label="Show password">
                                <svg class="eye-open" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                                <svg class="eye-closed" style="display:none" viewBox="0 0 24 24"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>
                            </button>
                        </div>
                    </div>
                    <div class="terms-checkbox">
                        <input type="checkbox" id="termsCheckbox" required>
                        <label for="termsCheckbox">I agree to the <a href="#" onclick="openLegalModal('terms'); return false;">Terms of Service</a> and <a href="#" onclick="openLegalModal('privacy'); return false;">Privacy Policy</a></label>
                    </div>
                    <button type="submit" class="btn btn-primary">Create Account</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal settings-modal">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <label class="settings-label">Account</label>
                    <span class="settings-value" id="settingsEmail"></span>
                </div>
                <div class="settings-section">
                    <span class="account-link" onclick="openChangePasswordModal()">Change Password</span>
                    <span class="account-link danger" onclick="openDeleteAccountModal()">Delete Account</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Folder Selection Modal -->
    <div class="modal-overlay" id="folderModal">
        <div class="modal folder-modal">
            <div class="modal-header">
                <h2>Save to Folder</h2>
                <button class="modal-close" onclick="closeFolderModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="folder-list" id="folderList">
                    <!-- Folders will be populated here -->
                </div>
                <div class="folder-create" id="folderCreateSection">
                    <input type="text" id="newFolderName" placeholder="New folder name..." maxlength="50">
                    <button class="btn btn-primary" onclick="createFolder()">Create</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Change Password Modal -->
    <div class="modal-overlay" id="changePasswordModal">
        <div class="modal">
            <div class="modal-header">
                <h2>Change Password</h2>
                <button class="modal-close" onclick="closeChangePasswordModal()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="changePasswordForm" onsubmit="handleChangePassword(event)">
                    <div class="form-group">
                        <label for="newPassword">New Password</label>
                        <div class="password-input-wrapper">
                            <input type="password" id="newPassword" required minlength="6" placeholder="At least 6 characters">
                            <button type="button" class="password-toggle" onclick="togglePasswordVisibility('newPassword', this)" aria-label="Show password">
                                <svg class="eye-open" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                                <svg class="eye-closed" style="display:none" viewBox="0 0 24 24"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>
                            </button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="confirmNewPassword">Confirm New Password</label>
                        <div class="password-input-wrapper">
                            <input type="password" id="confirmNewPassword" required minlength="6" placeholder="Confirm new password">
                            <button type="button" class="password-toggle" onclick="togglePasswordVisibility('confirmNewPassword', this)" aria-label="Show password">
                                <svg class="eye-open" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                                <svg class="eye-closed" style="display:none" viewBox="0 0 24 24"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>
                            </button>
                        </div>
                    </div>
                    <button type="submit" class="btn btn-primary">Update Password</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Logout Confirmation Modal -->
    <div class="modal-overlay" id="logoutModal">
        <div class="modal confirm-modal">
            <div class="modal-header">
                <h2>Log Out</h2>
                <button class="modal-close" onclick="closeLogoutModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to log out?</p>
                <div class="confirm-modal-buttons">
                    <button class="btn btn-secondary" onclick="closeLogoutModal()">No</button>
                    <button class="btn btn-primary" onclick="confirmLogout()">Yes</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Account Modal -->
    <div class="modal-overlay" id="deleteAccountModal">
        <div class="modal delete-modal">
            <div class="modal-header">
                <h2>Delete Account</h2>
                <button class="modal-close" onclick="closeDeleteAccountModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="delete-warning">
                    <strong>Warning:</strong> This action cannot be undone. All your saved artworks and folders will be permanently deleted.
                </div>
                <p>To confirm deletion, type <strong>DELETE</strong> below:</p>
                <div class="form-group">
                    <input type="text" id="deleteConfirmInput" placeholder="Type DELETE to confirm">
                </div>
                <div class="delete-modal-buttons">
                    <button class="btn btn-secondary" onclick="closeDeleteAccountModal()">Cancel</button>
                    <button class="btn btn-danger" onclick="confirmDeleteAccount()">Delete My Account</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Privacy Policy Modal -->
    <div class="modal-overlay" id="privacyModal">
        <div class="modal legal-modal">
            <div class="modal-header">
                <h2>Privacy Policy</h2>
                <button class="modal-close" onclick="closeLegalModal('privacy')">&times;</button>
            </div>
            <div class="modal-body legal-content">
                <p><em>Last updated: January 2025</em></p>

                <p>Chiron collects and stores the following data when you create an account:</p>

                <h3>What We Collect</h3>
                <ul>
                    <li>Email address and password (for authentication)</li>
                    <li>Saved artworks (artworks you add to your collection)</li>
                    <li>Folders (how you organize your saved artworks)</li>
                </ul>

                <h3>How We Use It</h3>
                <ul>
                    <li>To provide the service and save your collection</li>
                    <li>To sync your data across devices</li>
                    <li>To generate personalized recommendations based on your saves</li>
                    <li>To generate anonymous community statistics (such as trending artworks)</li>
                </ul>

                <h3>Recommendations</h3>
                <ul>
                    <li>We track which artworks are saved by users</li>
                    <li>This data is used to recommend artworks to users with similar taste</li>
                    <li>Your individual saves are never publicly displayed or linked to your identity</li>
                    <li>Example: "Users who saved this also saved..." - we do not show WHO saved it</li>
                </ul>

                <h3>How We Store It</h3>
                <ul>
                    <li>Your data is stored securely using Supabase (a cloud database provider)</li>
                    <li>We do not sell or share your personal data with third parties</li>
                    <li>We do not use your data for advertising</li>
                    <li>We do not use tracking or analytics</li>
                </ul>

                <h3>Your Rights</h3>
                <ul>
                    <li>You can delete your account and all associated data at any time from your account settings</li>
                    <li>Account deletion is immediate and permanent</li>
                    <li>Anonymized aggregate data may remain in recommendation algorithms after deletion</li>
                </ul>

                <h3>Cookies</h3>
                <ul>
                    <li>We use browser localStorage to cache data for performance</li>
                    <li>No tracking cookies are used</li>
                </ul>

                <h3>Third Party Content</h3>
                <ul>
                    <li>Artworks displayed in Chiron are sourced from public museum APIs and partner galleries</li>
                    <li>We do not host artwork images directly</li>
                    <li>Clicking "Buy" or "View Original" links will take you to third party websites with their own privacy policies</li>
                </ul>

                <h3>Age Requirement</h3>
                <p>You must be 13 years or older to create an account.</p>

                <p><strong>By creating an account, you consent to this data collection and storage.</strong></p>
            </div>
        </div>
    </div>

    <!-- Terms of Service Modal -->
    <div class="modal-overlay" id="termsModal">
        <div class="modal legal-modal">
            <div class="modal-header">
                <h2>Terms of Service</h2>
                <button class="modal-close" onclick="closeLegalModal('terms')">&times;</button>
            </div>
            <div class="modal-body legal-content">
                <p><em>Last updated: January 2025</em></p>

                <p>By using Chiron, you agree to the following:</p>

                <h3>1. Account</h3>
                <ul>
                    <li>You must provide a valid email address</li>
                    <li>You are responsible for your account security</li>
                    <li>You must be 13 years or older to use this service</li>
                    <li>You may delete your account at any time from your account settings</li>
                </ul>

                <h3>2. Acceptable Use</h3>
                <ul>
                    <li>Do not abuse the service or attempt to access other users' data</li>
                    <li>Do not use automated tools to scrape or bulk download content</li>
                    <li>Do not attempt to circumvent any access restrictions</li>
                </ul>

                <h3>3. Content</h3>
                <ul>
                    <li>Artworks displayed are sourced from public museum APIs and partner galleries</li>
                    <li>We do not claim ownership of any artwork displayed</li>
                    <li>All artworks remain the property of their respective owners and institutions</li>
                </ul>

                <h3>4. Third Party Links</h3>
                <ul>
                    <li>Chiron may contain links to third party websites (museums, galleries, print services)</li>
                    <li>We are not responsible for the content or practices of these websites</li>
                    <li>Purchases made through third party links are subject to their terms</li>
                </ul>

                <h3>5. Recommendations</h3>
                <ul>
                    <li>Your saved artworks may be used to generate recommendations for other users</li>
                    <li>This data is anonymized - your identity is never revealed</li>
                    <li>See our Privacy Policy for full details</li>
                </ul>

                <h3>6. Service</h3>
                <ul>
                    <li>The service is provided "as is"</li>
                    <li>We may modify or discontinue the service at any time</li>
                    <li>We are not liable for data loss</li>
                    <li>Artwork availability depends on third party APIs and may change</li>
                </ul>

                <h3>7. Account Deletion</h3>
                <ul>
                    <li>You may delete your account at any time from your account settings</li>
                    <li>Deleting your account permanently removes all your data including saved artworks</li>
                    <li>This action cannot be undone</li>
                    <li>Anonymized aggregate data may remain in recommendation algorithms</li>
                </ul>

                <h3>8. Intellectual Property</h3>
                <ul>
                    <li>The Chiron name, logo, and app design are our property</li>
                    <li>You may not copy or reproduce the app without permission</li>
                </ul>

                <h3>9. Changes</h3>
                <ul>
                    <li>We may update these terms at any time</li>
                    <li>Continued use means acceptance of new terms</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Expanded View Overlay -->
    <div class="expanded-overlay" id="expandedOverlay">
        <div class="swipe-indicator"></div>
        <button class="expanded-close-btn" id="expandedCloseBtn" aria-label="Close">
            <svg viewBox="0 0 24 24" fill="none">
                <path d="M18 6L6 18M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </button>
        <div class="expanded-container">
            <!-- Left Panel: Image and details -->
            <div class="expanded-left-panel">
                <div class="expanded-content" id="expandedContent">
                    <div class="expanded-image-container" id="expandedImageContainer">
                        <img class="expanded-image" id="expandedImage" src="" alt="">
                        <button class="expanded-download-btn expanded-save-btn" id="expandedSaveBtn" aria-label="Save artwork" style="right: 4.5rem;">
                            <svg viewBox="0 0 24 24">
                                <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                            </svg>
                        </button>
                        <button class="expanded-download-btn" id="expandedDownloadBtn" aria-label="Download image">
                            <svg viewBox="0 0 24 24">
                                <path d="M12 15V3m0 12l-4-4m4 4l4-4M2 17l.621 2.485A2 2 0 0 0 4.561 21h14.878a2 2 0 0 0 1.94-1.515L22 17" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                        <a class="source-badge" id="expandedSourceBadge" href="#" target="_blank" rel="noopener"></a>
                    </div>
                    <div class="expanded-details" id="expandedDetails">
                        <!-- Additional metadata will be populated by JS -->
                    </div>
                </div>
            </div>
            <!-- Right Panel: Grid of artworks (same as Explore) -->
            <div class="expanded-right-grid" id="expandedRightGrid">
                <div class="grid-title">You might also like</div>
                <div class="art-grid" id="expandedArtGrid">
                    <!-- Tiles will be populated using createTile() -->
                </div>
                <div class="loading-indicator" id="expandedGridLoading" style="display: none;">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Buffer indicator -->
    <div class="buffer-indicator" id="bufferIndicator" style="display: none;">
        <span id="bufferCount">0</span> preloaded
        <div class="buffer-bar">
            <div class="buffer-fill" id="bufferFill" style="width: 0%"></div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="app-footer">
        <a href="#" onclick="openLegalModal('privacy'); return false;">Privacy Policy</a>
        <span class="footer-divider">|</span>
        <a href="#" onclick="openLegalModal('terms'); return false;">Terms of Service</a>
    </footer>

    <script>
        // ===== State Management =====
        const state = {
            currentTab: 'explore',
            exploreArtworks: [],      // Currently displayed artworks
            exploreBuffer: [],        // Pre-fetched artworks ready to display
            searchArtworks: [],
            searchBuffer: [],
            isLoading: false,
            isFetchingBuffer: false,  // Background fetching in progress
            metOffset: 0,
            wikimediaOffset: 0,
            searchMetOffset: 0,
            searchWikimediaOffset: 0,
            seenIds: new Set(),
            searchSeenIds: new Set(),
            darkMode: true,
            currentSearchQuery: '',
            currentSearchFilters: {},
            bufferTarget: 80,         // Buffer target with rate limit protection
            displayBatchSize: 16,     // How many to show at once when scrolling
            expandedArtwork: null,    // Currently expanded artwork
            // Expanded grid state (same approach as Explore)
            expandedGridArtworks: [],     // Artworks shown in expanded view right grid
            expandedGridSeenIds: new Set(), // Track seen IDs in expanded grid
            isLoadingMoreExpandedGrid: false, // Loading flag for infinite scroll
            // For You tab state
            forYouArtworks: [],       // Currently displayed For You artworks
            forYouBuffer: [],         // Pre-fetched For You recommendations
            forYouSeenIds: new Set(), // Track seen artworks in For You
            forYouLoaded: false       // Whether For You has been loaded once
        };

        // ===== Device Detection =====
        const isTouchDevice = () => {
            return window.matchMedia('(hover: none)').matches ||
                   ('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0);
        };

        // Apply touch/no-touch class to document
        function applyDeviceClass() {
            if (isTouchDevice()) {
                document.documentElement.classList.add('touch-device');
                document.documentElement.classList.remove('no-touch');
            } else {
                document.documentElement.classList.add('no-touch');
                document.documentElement.classList.remove('touch-device');
            }
        }

        // ===== Supabase Configuration =====
        const SUPABASE_URL = 'https://suwhtrffccoivvpdfomb.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN1d2h0cmZmY2NvaXZ2cGRmb21iIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkyMTI5MjgsImV4cCI6MjA4NDc4ODkyOH0.lDG3M7OSzHGhKEIUBvOYNbPNzjC6k1sq8COUYPEmaU0';
        const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // ===== Auth State & Functions =====
        let currentUser = null;
        let userSavesCache = null;
        let userFoldersCache = null;
        let pendingSaveArtwork = null; // Artwork waiting to be saved after folder selection

        function openAuthModal(tab = 'login') {
            switchAuthTab(tab);
            document.getElementById('authModal').classList.add('active');
        }

        function closeAuthModal() {
            document.getElementById('authModal').classList.remove('active');
            clearAuthForms();
            // Reset to login tab view
            document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));
            document.getElementById('loginForm').classList.add('active');
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            document.querySelector('.auth-tab:first-child').classList.add('active');
        }

        function openSettingsModal() {
            document.getElementById('settingsEmail').textContent = currentUser?.email || '';
            document.getElementById('settingsModal').classList.add('active');
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').classList.remove('active');
        }

        function switchAuthTab(tab) {
            // Hide all forms
            document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            document.getElementById('authError').classList.remove('visible');
            document.getElementById('authSuccess').classList.remove('visible');

            if (tab === 'login') {
                document.getElementById('loginForm').classList.add('active');
                document.querySelector('.auth-tab:first-child').classList.add('active');
            } else if (tab === 'signup') {
                document.getElementById('signupForm').classList.add('active');
                document.querySelector('.auth-tab:last-child').classList.add('active');
            }
        }

        function clearAuthForms() {
            document.getElementById('loginEmail').value = '';
            document.getElementById('loginPassword').value = '';
            document.getElementById('signupEmail').value = '';
            document.getElementById('signupPassword').value = '';
            document.getElementById('signupConfirm').value = '';
            document.getElementById('forgotEmail').value = '';
            document.getElementById('authError').classList.remove('visible');
            document.getElementById('authSuccess').classList.remove('visible');
        }

        function showAuthError(message) {
            const errorEl = document.getElementById('authError');
            errorEl.textContent = message;
            errorEl.classList.add('visible');
            document.getElementById('authSuccess').classList.remove('visible');
        }

        function togglePasswordVisibility(inputId, button) {
            const input = document.getElementById(inputId);
            const eyeOpen = button.querySelector('.eye-open');
            const eyeClosed = button.querySelector('.eye-closed');

            if (input.type === 'password') {
                input.type = 'text';
                eyeOpen.style.display = 'none';
                eyeClosed.style.display = 'block';
                button.setAttribute('aria-label', 'Hide password');
            } else {
                input.type = 'password';
                eyeOpen.style.display = 'block';
                eyeClosed.style.display = 'none';
                button.setAttribute('aria-label', 'Show password');
            }
        }

        function showAuthSuccess(message) {
            const successEl = document.getElementById('authSuccess');
            successEl.textContent = message;
            successEl.classList.add('visible');
            document.getElementById('authError').classList.remove('visible');
        }

        function showForgotPassword() {
            document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));
            document.getElementById('forgotPasswordForm').classList.add('active');
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            document.getElementById('authError').classList.remove('visible');
            document.getElementById('authSuccess').classList.remove('visible');
        }

        function backToLogin() {
            document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));
            document.getElementById('loginForm').classList.add('active');
            document.querySelectorAll('.auth-tab')[0].classList.add('active');
            document.getElementById('authError').classList.remove('visible');
            document.getElementById('authSuccess').classList.remove('visible');
        }

        async function handleForgotPassword(e) {
            e.preventDefault();
            const email = document.getElementById('forgotEmail').value.trim();

            if (!email) {
                showAuthError('Please enter your email address');
                return;
            }

            try {
                const { error } = await supabaseClient.auth.resetPasswordForEmail(email, {
                    redirectTo: window.location.origin + window.location.pathname
                });

                if (error) {
                    showAuthError(error.message);
                    return;
                }

                showAuthSuccess('Password reset link sent! Check your email.');
                document.getElementById('forgotEmail').value = '';
            } catch (err) {
                showAuthError('Failed to send reset link. Please try again.');
                console.error('Password reset error:', err);
            }
        }

        async function handleLogin(e) {
            e.preventDefault();
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;

            if (!email || !password) {
                showAuthError('Please enter email and password');
                return;
            }

            try {
                const { data, error } = await supabaseClient.auth.signInWithPassword({
                    email: email,
                    password: password
                });

                if (error) {
                    showAuthError(error.message);
                    return;
                }

                // Success - auth state change listener will handle the rest
                closeAuthModal();
                showToast(`Welcome back, ${email.split('@')[0]}!`);
            } catch (err) {
                showAuthError('Login failed: ' + (err.message || err));
                console.error('Login error:', err);
            }
        }

        async function handleSignup(e) {
            e.preventDefault();
            const email = document.getElementById('signupEmail').value.trim();
            const password = document.getElementById('signupPassword').value;
            const confirm = document.getElementById('signupConfirm').value;
            const termsChecked = document.getElementById('termsCheckbox').checked;

            if (!email || !password) {
                showAuthError('Please fill in all fields');
                return;
            }

            if (!termsChecked) {
                showAuthError('Please agree to the Terms of Service and Privacy Policy');
                return;
            }

            if (password !== confirm) {
                showAuthError('Passwords do not match');
                return;
            }

            if (password.length < 6) {
                showAuthError('Password must be at least 6 characters');
                return;
            }

            try {
                console.log('Attempting signup with:', email);
                const { data, error } = await supabaseClient.auth.signUp({
                    email: email,
                    password: password
                });
                console.log('Signup response:', { data, error });

                if (error) {
                    showAuthError(error.message);
                    return;
                }

                // Check if email confirmation is required
                if (data.user && !data.session) {
                    console.log('User created but no session - email confirmation may be required');
                    showAuthSuccess('Check your email for a confirmation link!');
                    return;
                }

                // Success - auth state change listener will handle the rest
                console.log('Signup successful, session created');
                closeAuthModal();
                showToast(`Account created! Welcome, ${email.split('@')[0]}!`);
            } catch (err) {
                showAuthError('Signup failed. Please try again.');
                console.error('Signup error:', err);
            }
        }

        function openLogoutModal() {
            document.getElementById('logoutModal').classList.add('active');
        }

        function closeLogoutModal() {
            document.getElementById('logoutModal').classList.remove('active');
        }

        async function confirmLogout() {
            try {
                await supabaseClient.auth.signOut();
                currentUser = null;
                userSavesCache = null;
                updateAuthUI();
                closeLogoutModal();
                showToast('You have been logged out');
            } catch (err) {
                console.error('Logout error:', err);
                showToast('Error logging out');
            }
        }

        // Change Password Modal
        function openChangePasswordModal() {
            closeSettingsModal();
            document.getElementById('changePasswordModal').classList.add('active');
            document.getElementById('newPassword').value = '';
            document.getElementById('confirmNewPassword').value = '';
        }

        function closeChangePasswordModal() {
            document.getElementById('changePasswordModal').classList.remove('active');
        }

        async function handleChangePassword(e) {
            e.preventDefault();
            const newPassword = document.getElementById('newPassword').value;
            const confirmPassword = document.getElementById('confirmNewPassword').value;

            if (newPassword !== confirmPassword) {
                showToast('Passwords do not match');
                return;
            }

            if (newPassword.length < 6) {
                showToast('Password must be at least 6 characters');
                return;
            }

            try {
                const { error } = await supabaseClient.auth.updateUser({
                    password: newPassword
                });

                if (error) {
                    showToast(error.message);
                    return;
                }

                closeChangePasswordModal();
                showToast('Password updated successfully');
            } catch (err) {
                console.error('Change password error:', err);
                showToast('Failed to update password');
            }
        }

        // Delete Account Modal
        function openDeleteAccountModal() {
            closeSettingsModal();
            document.getElementById('deleteAccountModal').classList.add('active');
            document.getElementById('deleteConfirmInput').value = '';
        }

        function closeDeleteAccountModal() {
            document.getElementById('deleteAccountModal').classList.remove('active');
        }

        async function confirmDeleteAccount() {
            const confirmInput = document.getElementById('deleteConfirmInput').value;

            if (confirmInput !== 'DELETE') {
                showToast('Please type DELETE to confirm');
                return;
            }

            try {
                // Delete user's saves first
                if (currentUser) {
                    await supabaseClient
                        .from('chiron_saves')
                        .delete()
                        .eq('user_id', currentUser.id);

                    // Delete user's folders
                    await supabaseClient
                        .from('chiron_folders')
                        .delete()
                        .eq('user_id', currentUser.id);
                }

                // Sign out
                await supabaseClient.auth.signOut();
                currentUser = null;
                userSavesCache = null;
                updateAuthUI();
                closeDeleteAccountModal();
                showToast('Account deleted successfully');
            } catch (err) {
                console.error('Delete account error:', err);
                showToast('Failed to delete account');
            }
        }

        // Legal Modals
        function openLegalModal(type) {
            if (type === 'privacy') {
                document.getElementById('privacyModal').classList.add('active');
            } else if (type === 'terms') {
                document.getElementById('termsModal').classList.add('active');
            }
        }

        function closeLegalModal(type) {
            if (type === 'privacy') {
                document.getElementById('privacyModal').classList.remove('active');
            } else if (type === 'terms') {
                document.getElementById('termsModal').classList.remove('active');
            }
        }

        function updateAuthUI() {
            const authButtons = document.getElementById('authButtons');
            const forYouTabBtn = document.getElementById('forYouTabBtn');

            if (currentUser) {
                authButtons.innerHTML = `
                    <button class="auth-btn auth-btn-primary" onclick="openSettingsModal()">Settings</button>
                    <button class="auth-btn auth-btn-secondary" onclick="openLogoutModal()">Log Out</button>`;
                // Show For You tab when logged in
                forYouTabBtn.style.display = '';
            } else {
                authButtons.innerHTML = `
                    <button class="auth-btn auth-btn-secondary" onclick="openAuthModal('login')">Log In</button>
                    <button class="auth-btn auth-btn-primary" onclick="openAuthModal('signup')">Sign Up</button>`;
                // Hide For You tab when logged out
                forYouTabBtn.style.display = 'none';
                // If user is on For You tab, redirect to Explore
                if (state.currentTab === 'foryou') {
                    switchTab('explore');
                }
            }
        }

        // ===== Supabase Saves Functions =====
        async function fetchUserSaves() {
            if (!currentUser) return [];

            try {
                const { data, error } = await supabaseClient
                    .from('chiron_saves')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .order('saved_at', { ascending: false });

                if (error) throw error;
                userSavesCache = data || [];
                return userSavesCache;
            } catch (err) {
                console.error('Error fetching saves:', err);
                return [];
            }
        }

        async function saveArtwork(artwork) {
            if (!currentUser) {
                showToast('Please log in to save artworks');
                openAuthModal('login');
                return false;
            }

            // Store artwork and open folder selection modal
            pendingSaveArtwork = artwork;
            openFolderModal();
            return true; // Return true to update UI immediately, actual save happens after folder selection
        }

        // Upload thumbnail to Supabase Storage and return the public URL
        async function uploadThumbnail(imageUrl, artworkId) {
            try {
                // Fetch the image
                const response = await fetch(imageUrl, { mode: 'cors' });
                if (!response.ok) throw new Error('Failed to fetch image');

                const blob = await response.blob();

                // Create a canvas to resize the image
                const img = new Image();
                img.crossOrigin = 'anonymous';

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = URL.createObjectURL(blob);
                });

                // Resize to thumbnail (max 200px)
                const maxSize = 200;
                let width = img.width;
                let height = img.height;

                if (width > height) {
                    if (width > maxSize) {
                        height = Math.round((height * maxSize) / width);
                        width = maxSize;
                    }
                } else {
                    if (height > maxSize) {
                        width = Math.round((width * maxSize) / height);
                        height = maxSize;
                    }
                }

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);

                // Convert to blob
                const thumbnailBlob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/jpeg', 0.8);
                });

                // Upload to Supabase Storage
                const fileName = `${currentUser.id}/${artworkId.replace(/[^a-zA-Z0-9_-]/g, '_')}.jpg`;

                const { data, error } = await supabaseClient.storage
                    .from('thumbnails')
                    .upload(fileName, thumbnailBlob, {
                        contentType: 'image/jpeg',
                        upsert: true
                    });

                if (error) throw error;

                // Get public URL
                const { data: urlData } = supabaseClient.storage
                    .from('thumbnails')
                    .getPublicUrl(fileName);

                URL.revokeObjectURL(img.src);
                return urlData.publicUrl;
            } catch (error) {
                console.warn('Failed to upload thumbnail:', error);
                return null; // Return null if upload fails, will fall back to original URL
            }
        }

        async function saveArtworkWithFolder(artwork, folderId) {
            if (!folderId) {
                showToast('Please select or create a folder');
                return false;
            }

            try {
                // Try to upload thumbnail to Supabase Storage
                const storedThumbnailUrl = await uploadThumbnail(
                    artwork.thumbnailUrl || artwork.imageUrl,
                    artwork.uniqueId || artwork.id
                );

                const insertData = {
                    user_id: currentUser.id,
                    artwork_id: artwork.uniqueId || artwork.id,
                    source: artwork.source,
                    title: artwork.title,
                    artist: artwork.artist,
                    date_created: artwork.date,
                    medium: artwork.medium,
                    image_url: artwork.imageUrl,
                    thumbnail_url: storedThumbnailUrl || artwork.thumbnailUrl, // Use stored URL or fallback
                    source_url: artwork.sourceUrl,
                    folder_id: folderId,
                    metadata: {
                        dimensions: artwork.dimensions,
                        department: artwork.department,
                        culture: artwork.culture,
                        period: artwork.period,
                        classification: artwork.classification,
                        creditLine: artwork.creditLine,
                        repository: artwork.repository
                    }
                };

                const { data, error } = await supabaseClient
                    .from('chiron_saves')
                    .insert(insertData)
                    .select()
                    .single();

                if (error) {
                    if (error.code === '23505') {
                        showToast('Already saved!');
                        return false;
                    }
                    throw error;
                }

                // Update cache
                if (userSavesCache) {
                    userSavesCache.unshift(data);
                }

                // Mark For You as needing refresh (new save may affect recommendations)
                state.forYouLoaded = false;

                const folderName = folderId ? userFoldersCache?.find(f => f.id === folderId)?.name : null;
                showToast(folderName ? `Saved to "${folderName}"` : 'Artwork saved!');
                return true;
            } catch (err) {
                console.error('Error saving artwork:', err);
                showToast('Error saving artwork');
                return false;
            }
        }

        // ===== Folder Management =====
        async function fetchUserFolders() {
            if (!currentUser) return [];

            try {
                const { data, error } = await supabaseClient
                    .from('chiron_folders')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .order('name', { ascending: true });

                if (error) throw error;
                userFoldersCache = data || [];
                return userFoldersCache;
            } catch (err) {
                console.error('Error fetching folders:', err);
                return [];
            }
        }

        async function createNewFolder(name) {
            if (!currentUser || !name.trim()) return null;

            try {
                const { data, error } = await supabaseClient
                    .from('chiron_folders')
                    .insert({
                        user_id: currentUser.id,
                        name: name.trim()
                    })
                    .select()
                    .single();

                if (error) throw error;

                // Update cache
                if (userFoldersCache) {
                    userFoldersCache.push(data);
                    userFoldersCache.sort((a, b) => a.name.localeCompare(b.name));
                }

                return data;
            } catch (err) {
                console.error('Error creating folder:', err);
                if (err.code === '23505') {
                    showToast('Folder already exists');
                } else {
                    showToast('Error creating folder');
                }
                return null;
            }
        }

        async function getFolderSaveCounts() {
            if (!currentUser) return {};

            try {
                const { data, error } = await supabaseClient
                    .from('chiron_saves')
                    .select('folder_id')
                    .eq('user_id', currentUser.id)
                    .not('folder_id', 'is', null);

                if (error) throw error;

                const counts = {};
                data.forEach(save => {
                    counts[save.folder_id] = (counts[save.folder_id] || 0) + 1;
                });
                return counts;
            } catch (err) {
                console.error('Error getting folder counts:', err);
                return {};
            }
        }

        function openFolderModal() {
            const modal = document.getElementById('folderModal');
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
            renderFolderList();
        }

        function closeFolderModal() {
            const modal = document.getElementById('folderModal');
            modal.classList.remove('active');
            document.body.style.overflow = '';
            document.getElementById('newFolderName').value = '';

            // If modal closed without saving, revert the save button state
            if (pendingSaveArtwork) {
                // Find and reset the save button that was clicked
                const artworkId = pendingSaveArtwork.uniqueId || pendingSaveArtwork.id;
                const source = pendingSaveArtwork.source;

                // Check if it was actually saved
                if (!isArtworkSaved(artworkId, source)) {
                    // Reset any save buttons for this artwork
                    document.querySelectorAll('.save-btn.saved').forEach(btn => {
                        const tile = btn.closest('.art-tile');
                        if (tile) {
                            const tileArtwork = tile._artwork;
                            if (tileArtwork && tileArtwork.uniqueId === artworkId && tileArtwork.source === source) {
                                btn.classList.remove('saved');
                            }
                        }
                    });
                    // Also check expanded view
                    const expandedSaveBtn = document.getElementById('expandedSaveBtn');
                    if (expandedSaveBtn && state.expandedArtwork) {
                        if (state.expandedArtwork.uniqueId === artworkId && state.expandedArtwork.source === source) {
                            expandedSaveBtn.classList.remove('saved');
                        }
                    }
                }
                pendingSaveArtwork = null;
            }
        }

        async function renderFolderList() {
            const listEl = document.getElementById('folderList');
            listEl.innerHTML = '<div class="folder-empty">Loading folders...</div>';

            // Fetch folders if not cached
            if (!userFoldersCache) {
                await fetchUserFolders();
            }

            const counts = await getFolderSaveCounts();
            const thumbnails = await getFolderThumbnails();

            if (!userFoldersCache || userFoldersCache.length === 0) {
                listEl.innerHTML = '<div class="folder-empty">Create a folder to save artworks</div>';
                return;
            }

            listEl.innerHTML = userFoldersCache.map(folder => {
                const thumb = thumbnails[folder.id];
                const placeholderSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>`;
                const thumbHtml = thumb
                    ? `<div class="folder-item-thumb-wrapper">
                        <img class="folder-item-thumb" src="${thumb}" alt="" crossorigin="anonymous" referrerpolicy="no-referrer"
                            onload="this.style.opacity='1';"
                            onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                            style="opacity: 0; transition: opacity 0.2s;">
                        <div class="folder-item-placeholder" style="display:none;">${placeholderSvg}</div>
                       </div>`
                    : `<div class="folder-item-placeholder">${placeholderSvg}</div>`;
                return `
                    <div class="folder-item" onclick="selectFolder('${folder.id}')">
                        ${thumbHtml}
                        <span class="folder-item-name">${escapeHtml(folder.name)}</span>
                        <span class="folder-item-count">${counts[folder.id] || 0}</span>
                    </div>
                `;
            }).join('');
        }

        async function getFolderThumbnails() {
            if (!currentUser) return {};

            try {
                const { data, error } = await supabaseClient
                    .from('chiron_saves')
                    .select('folder_id, thumbnail_url, image_url')
                    .eq('user_id', currentUser.id)
                    .not('folder_id', 'is', null)
                    .order('saved_at', { ascending: true });

                if (error) throw error;

                // Get first image for each folder
                const thumbnails = {};
                for (const save of (data || [])) {
                    if (!thumbnails[save.folder_id]) {
                        thumbnails[save.folder_id] = save.thumbnail_url || save.image_url;
                    }
                }
                return thumbnails;
            } catch (error) {
                console.error('Error fetching folder thumbnails:', error);
                return {};
            }
        }

        async function selectFolder(folderId) {
            if (!pendingSaveArtwork) return;

            const artwork = pendingSaveArtwork;
            pendingSaveArtwork = null;
            closeFolderModal();

            await saveArtworkWithFolder(artwork, folderId);
        }

        async function createFolder() {
            const input = document.getElementById('newFolderName');
            const name = input.value.trim();

            if (!name) {
                showToast('Please enter a folder name');
                return;
            }

            const folder = await createNewFolder(name);
            if (folder) {
                input.value = '';
                // Save to the new folder immediately
                if (pendingSaveArtwork) {
                    await selectFolder(folder.id);
                } else {
                    renderFolderList();
                }
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function unsaveArtwork(artworkId, source) {
            if (!currentUser) return false;

            try {
                const { error } = await supabaseClient
                    .from('chiron_saves')
                    .delete()
                    .eq('user_id', currentUser.id)
                    .eq('artwork_id', artworkId)
                    .eq('source', source);

                if (error) throw error;

                // Update cache
                if (userSavesCache) {
                    userSavesCache = userSavesCache.filter(s =>
                        !(s.artwork_id === artworkId && s.source === source)
                    );
                }

                // Mark For You as needing refresh (save count changed)
                state.forYouLoaded = false;

                showToast('Artwork removed from saves');
                return true;
            } catch (err) {
                console.error('Error removing save:', err);
                showToast('Error removing artwork');
                return false;
            }
        }

        function isArtworkSaved(artworkId, source) {
            if (!userSavesCache) return false;
            return userSavesCache.some(s => s.artwork_id === artworkId && s.source === source);
        }

        // ===== Artwork Recommendations =====
        const recommendationsCache = new Map();
        const RECOMMENDATIONS_CACHE_TTL = 60 * 60 * 1000; // 1 hour

        async function fetchRecommendations(artworkId, source) {
            // Check cache first
            const cacheKey = `${artworkId}_${source}`;
            const cached = recommendationsCache.get(cacheKey);
            if (cached && Date.now() - cached.timestamp < RECOMMENDATIONS_CACHE_TTL) {
                return cached.data;
            }

            try {
                const { data, error } = await supabaseClient.rpc('get_artwork_recommendations', {
                    p_artwork_id: artworkId,
                    p_source: source,
                    p_limit: 24
                });

                if (error) {
                    console.error('Error fetching recommendations:', error);
                    return [];
                }

                // Cache the results
                recommendationsCache.set(cacheKey, {
                    data: data || [],
                    timestamp: Date.now()
                });

                return data || [];
            } catch (err) {
                console.error('Failed to fetch recommendations:', err);
                return [];
            }
        }

        // Load expanded view right grid - uses same tiles and logic as Explore tab
        async function loadExpandedRightGrid(currentArtwork) {
            const container = document.getElementById('expandedRightGrid');
            const grid = document.getElementById('expandedArtGrid');
            const loading = document.getElementById('expandedGridLoading');
            const titleEl = container.querySelector('.grid-title');

            // Reset state
            grid.innerHTML = '';
            state.expandedGridArtworks = [];
            state.expandedGridSeenIds = new Set();
            state.expandedGridSeenIds.add(`${currentArtwork.uniqueId || currentArtwork.id}_${currentArtwork.source}`);

            // Show loading
            loading.style.display = 'flex';

            // First try to get algorithmic recommendations
            let recommendations = await fetchRecommendations(currentArtwork.uniqueId || currentArtwork.id, currentArtwork.source);
            const hasAlgorithmicResults = recommendations && recommendations.length > 0;

            // Convert recommendations to full artwork objects where possible
            const artworksToShow = [];
            if (recommendations && recommendations.length > 0) {
                recommendations.forEach(rec => {
                    state.expandedGridSeenIds.add(`${rec.artwork_id}_${rec.source}`);
                    // Create artwork object from recommendation
                    artworksToShow.push({
                        uniqueId: rec.artwork_id,
                        id: rec.artwork_id,
                        source: rec.source,
                        title: rec.title || 'Untitled',
                        artist: rec.artist || 'Unknown Artist',
                        thumbnailUrl: rec.thumbnail_url,
                        imageUrl: rec.thumbnail_url,
                        repository: getSourceDisplayName(rec.source),
                        sourceUrl: '#'
                    });
                });
            }

            // Use larger initial batch to fill the grid
            const initialBatchSize = 24;
            if (artworksToShow.length < initialBatchSize) {
                const needed = initialBatchSize - artworksToShow.length;
                const fallbackArtworks = await fetchExpandedGridArtworks(needed);
                artworksToShow.push(...fallbackArtworks);
            }

            loading.style.display = 'none';

            if (artworksToShow.length === 0) {
                titleEl.textContent = 'No artworks found';
                return;
            }

            // Update title
            titleEl.textContent = hasAlgorithmicResults ? 'Users who saved this also saved' : 'You might also like';

            // Store artworks and render using createTile (same as Explore)
            state.expandedGridArtworks = artworksToShow;
            renderExpandedGridTiles(artworksToShow, grid);

            // Pre-load more content to fill the grid (same pattern as Explore)
            setTimeout(() => {
                loadMoreExpandedGridArtworks();
                // Load another batch after a short delay
                setTimeout(() => loadMoreExpandedGridArtworks(), 500);
            }, 100);
        }

        // Render tiles in expanded grid - uses EXACT same createTile as Explore/Home
        function renderExpandedGridTiles(artworks, grid) {
            artworks.forEach(artwork => {
                // Use exact same createTile function as homepage - no modifications
                const tile = createTile(artwork);
                grid.appendChild(tile);
            });
        }

        // Fetch artworks for expanded grid - reuses same API calls as Explore
        async function fetchExpandedGridArtworks(count) {
            const artworks = [];
            const sources = ['aic', 'met', 'cleveland', 'wikimedia'].filter(s => apiAvailability[s] !== false);

            if (sources.length === 0) return artworks;

            // Use same fetching approach as Explore - parallel fetch from multiple sources
            const perSource = Math.ceil(count / sources.length) + 2;
            const fetchPromises = sources.map(async (source) => {
                try {
                    switch (source) {
                        case 'aic': return await fetchAICArtworks(perSource);
                        case 'met': return await fetchMetArtworks(perSource);
                        case 'cleveland': return await fetchClevelandArtworks(perSource);
                        case 'wikimedia': return await fetchWikimediaArtworks(perSource);
                        default: return [];
                    }
                } catch (e) {
                    console.warn(`Failed to fetch from ${source}:`, e);
                    return [];
                }
            });

            try {
                const results = await Promise.all(fetchPromises);
                for (const fetched of results) {
                    for (const art of (fetched || [])) {
                        if (!art) continue;
                        const key = `${art.uniqueId || art.id}_${art.source}`;
                        if (!state.expandedGridSeenIds.has(key) && artworks.length < count) {
                            state.expandedGridSeenIds.add(key);
                            artworks.push(art);
                        }
                    }
                }
            } catch (e) {
                console.warn('Error fetching expanded grid artworks:', e);
            }

            return artworks;
        }

        // Load more artworks for expanded grid (infinite scroll)
        async function loadMoreExpandedGridArtworks() {
            if (state.isLoadingMoreExpandedGrid) return;
            state.isLoadingMoreExpandedGrid = true;

            const grid = document.getElementById('expandedArtGrid');
            const loading = document.getElementById('expandedGridLoading');
            const batchSize = 20; // Larger batch for smoother scrolling

            loading.style.display = 'flex';

            try {
                const newArtworks = await fetchExpandedGridArtworks(batchSize);
                if (newArtworks.length > 0) {
                    state.expandedGridArtworks.push(...newArtworks);
                    renderExpandedGridTiles(newArtworks, grid);
                }
            } catch (e) {
                console.warn('Error loading more expanded grid artworks:', e);
            }

            loading.style.display = 'none';
            state.isLoadingMoreExpandedGrid = false;
        }

        // Track current folder being viewed (null = showing all folders)
        let currentViewingFolder = null;

        async function renderSavedGrid() {
            // If viewing a specific folder, render its contents
            if (currentViewingFolder) {
                await renderFolderContents(currentViewingFolder);
                return;
            }

            // Otherwise show all folders
            await showSavedFolders();
        }

        async function showSavedFolders() {
            currentViewingFolder = null;

            const grid = document.getElementById('savedGrid');
            const loading = document.getElementById('savedLoading');
            const empty = document.getElementById('savedEmpty');
            const loginPrompt = document.getElementById('savedLoginPrompt');
            const header = document.getElementById('savedHeader');

            // Hide all states initially
            grid.innerHTML = '';
            empty.style.display = 'none';
            loginPrompt.style.display = 'none';
            header.style.display = 'none';

            // Check if logged in
            if (!currentUser) {
                loginPrompt.style.display = 'flex';
                return;
            }

            // Show loading
            loading.style.display = 'flex';

            // Fetch folders and saves
            if (!userFoldersCache) {
                await fetchUserFolders();
            }
            if (!userSavesCache) {
                await fetchUserSaves();
            }

            loading.style.display = 'none';

            // Check if no folders
            if (!userFoldersCache || userFoldersCache.length === 0) {
                empty.style.display = 'flex';
                return;
            }

            // Group saves by folder
            const savesByFolder = {};
            (userSavesCache || []).forEach(save => {
                if (save.folder_id) {
                    if (!savesByFolder[save.folder_id]) {
                        savesByFolder[save.folder_id] = [];
                    }
                    savesByFolder[save.folder_id].push(save);
                }
            });

            // Render folder tiles
            userFoldersCache.forEach(folder => {
                const folderSaves = savesByFolder[folder.id] || [];
                const tile = createFolderTile(folder, folderSaves);
                grid.appendChild(tile);
            });
        }

        function createFolderTile(folder, saves) {
            const tile = document.createElement('div');
            tile.className = 'folder-tile';
            tile.onclick = () => openFolder(folder.id, folder.name);

            // Get first 4 thumbnails
            const thumbnails = saves.slice(0, 4).map(s => s.thumbnail_url || s.image_url);

            // Create 2x2 grid of thumbnails
            let gridHtml = '<div class="folder-tile-grid">';
            for (let i = 0; i < 4; i++) {
                if (thumbnails[i]) {
                    gridHtml += `<img class="folder-tile-thumb" src="${thumbnails[i]}" alt=""
                        onerror="this.outerHTML='<div class=\\'folder-tile-placeholder\\'><svg viewBox=\\'0 0 24 24\\' fill=\\'none\\' stroke=\\'currentColor\\' stroke-width=\\'2\\'><rect x=\\'3\\' y=\\'3\\' width=\\'18\\' height=\\'18\\' rx=\\'2\\'/><circle cx=\\'8.5\\' cy=\\'8.5\\' r=\\'1.5\\'/><path d=\\'M21 15l-5-5L5 21\\'/></svg></div>'">`;
                } else {
                    gridHtml += `<div class="folder-tile-placeholder">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <path d="M21 15l-5-5L5 21"/>
                        </svg>
                    </div>`;
                }
            }
            gridHtml += '</div>';

            tile.innerHTML = `
                ${gridHtml}
                <div class="folder-tile-info">
                    <div class="folder-tile-name">${escapeHtml(folder.name)}</div>
                    <div class="folder-tile-count">${saves.length} artwork${saves.length !== 1 ? 's' : ''}</div>
                </div>
            `;

            return tile;
        }

        async function openFolder(folderId, folderName) {
            currentViewingFolder = { id: folderId, name: folderName };
            await renderFolderContents(currentViewingFolder);
        }

        async function renderFolderContents(folder) {
            const grid = document.getElementById('savedGrid');
            const loading = document.getElementById('savedLoading');
            const empty = document.getElementById('savedEmpty');
            const header = document.getElementById('savedHeader');
            const folderTitle = document.getElementById('savedFolderTitle');

            // Show header with back button and folder name
            header.style.display = 'flex';
            folderTitle.textContent = folder.name;

            grid.innerHTML = '';
            empty.style.display = 'none';
            loading.style.display = 'flex';

            // Fetch saves if not cached
            if (!userSavesCache) {
                await fetchUserSaves();
            }

            loading.style.display = 'none';

            // Filter saves for this folder
            const folderSaves = (userSavesCache || []).filter(s => s.folder_id === folder.id);

            if (folderSaves.length === 0) {
                empty.innerHTML = `
                    <svg class="empty-icon" viewBox="0 0 24 24">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                    </svg>
                    <h3 class="empty-title">This folder is empty</h3>
                    <p class="empty-text">Save artworks to this folder from the Explore or Search tabs.</p>
                `;
                empty.style.display = 'flex';
                return;
            }

            // Render saved artworks in this folder
            folderSaves.forEach(save => {
                const artwork = {
                    uniqueId: save.artwork_id,
                    id: save.artwork_id,
                    source: save.source,
                    title: save.title || 'Untitled',
                    artist: save.artist || 'Unknown Artist',
                    date: save.date_created,
                    medium: save.medium,
                    imageUrl: save.image_url,
                    thumbnailUrl: save.thumbnail_url || save.image_url,
                    sourceUrl: save.source_url,
                    dimensions: save.metadata?.dimensions,
                    department: save.metadata?.department,
                    culture: save.metadata?.culture,
                    period: save.metadata?.period,
                    classification: save.metadata?.classification,
                    creditLine: save.metadata?.creditLine,
                    repository: save.metadata?.repository || getSourceDisplayName(save.source)
                };

                const tile = createTile(artwork);
                grid.appendChild(tile);
            });
        }

        // ===== For You Tab Functions =====
        async function loadForYouRecommendations() {
            const grid = document.getElementById('forYouGrid');
            const loading = document.getElementById('forYouLoading');
            const loginPrompt = document.getElementById('forYouLoginPrompt');
            const coldStart = document.getElementById('forYouColdStart');
            const empty = document.getElementById('forYouEmpty');

            // Hide all states initially
            grid.innerHTML = '';
            loading.style.display = 'none';
            loginPrompt.style.display = 'none';
            coldStart.style.display = 'none';
            empty.style.display = 'none';

            // Check if logged in
            if (!currentUser) {
                loginPrompt.style.display = 'flex';
                return;
            }

            // Show loading
            loading.style.display = 'flex';

            // Fetch saves if not cached
            if (!userSavesCache) {
                await fetchUserSaves();
            }

            // Initialize seen IDs from user saves
            state.forYouSeenIds = new Set(userSavesCache ? userSavesCache.map(s => `${s.source}-${s.artwork_id}`) : []);

            // Fetch recommendations (will include explore fallback automatically)
            try {
                let recommendations = [];

                // Try collaborative filtering if user has enough saves
                if (userSavesCache && userSavesCache.length >= 3) {
                    console.log('User has enough saves, fetching collaborative recommendations');
                    recommendations = await fetchForYouRecommendations();
                } else {
                    console.log('User has', userSavesCache ? userSavesCache.length : 0, 'saves, using explore fallback');
                }

                // If not enough results, supplement with explore artworks
                if (!recommendations || recommendations.length < 30) {
                    console.log('Fetching explore artworks as fallback...');
                    const exploreArtworks = await fetchExploreArtworksForFallback(
                        50 - (recommendations ? recommendations.length : 0),
                        state.forYouSeenIds
                    );
                    console.log('Got', exploreArtworks.length, 'explore artworks');
                    recommendations = [...(recommendations || []), ...exploreArtworks];
                }

                loading.style.display = 'none';

                if (!recommendations || recommendations.length === 0) {
                    // This should rarely happen now since we have explore fallback
                    empty.style.display = 'flex';
                    return;
                }

                // Add to buffer
                state.forYouBuffer = recommendations;

                // Filter out already saved artworks
                state.forYouBuffer = state.forYouBuffer.filter(art => {
                    const key = `${art.source}-${art.uniqueId}`;
                    if (state.forYouSeenIds.has(key)) return false;
                    state.forYouSeenIds.add(key);
                    return true;
                });

                // Shuffle to mix algorithmic and explore results
                state.forYouBuffer.sort(() => Math.random() - 0.5);

                // Display initial batch
                const initialBatch = state.forYouBuffer.splice(0, state.displayBatchSize);
                state.forYouArtworks = initialBatch;
                state.forYouLoaded = true;
                renderForYouGrid();

                // If buffer is low, fetch more in background
                if (state.forYouBuffer.length < 20) {
                    fetchMoreForYouRecommendations();
                }
            } catch (error) {
                console.error('Error loading For You recommendations:', error);
                loading.style.display = 'none';

                // Even on error, try to show explore artworks
                try {
                    const fallbackArtworks = await fetchExploreArtworksForFallback(50, state.forYouSeenIds);
                    if (fallbackArtworks.length > 0) {
                        state.forYouBuffer = fallbackArtworks;
                        const initialBatch = state.forYouBuffer.splice(0, state.displayBatchSize);
                        state.forYouArtworks = initialBatch;
                        state.forYouLoaded = true;
                        renderForYouGrid();
                        return;
                    }
                } catch (e) {
                    console.error('Fallback also failed:', e);
                }

                empty.style.display = 'flex';
            }
        }

        async function fetchForYouRecommendations() {
            if (!currentUser || !userSavesCache || userSavesCache.length < 3) {
                return [];
            }

            // Get user's saved artwork IDs for the collaborative filtering query
            const userSavedIds = userSavesCache.map(s => s.artwork_id);

            try {
                // Call Supabase RPC function for collaborative filtering
                const { data, error } = await supabaseClient.rpc('get_collaborative_recommendations', {
                    p_user_saved_ids: userSavedIds,
                    p_user_id: currentUser.id,
                    p_limit: 100
                });

                if (error) {
                    console.error('Collaborative filtering error:', error);
                    // Fallback to simple recommendations based on saved artworks
                    return await fetchFallbackRecommendations();
                }

                if (!data || data.length === 0) {
                    return await fetchFallbackRecommendations();
                }

                // Convert database results to artwork format
                return data.map(item => ({
                    uniqueId: item.artwork_id,
                    id: item.artwork_id,
                    source: item.source,
                    title: item.title || 'Untitled',
                    artist: item.artist || 'Unknown Artist',
                    date: item.date_created,
                    medium: item.medium,
                    imageUrl: item.image_url,
                    thumbnailUrl: item.thumbnail_url || item.image_url,
                    sourceUrl: item.source_url,
                    repository: getSourceDisplayName(item.source),
                    sharedSaves: item.shared_saves // How many users with similar taste saved this
                }));
            } catch (error) {
                console.error('Error fetching collaborative recommendations:', error);
                return await fetchFallbackRecommendations();
            }
        }

        async function fetchFallbackRecommendations() {
            // Fallback: get recommendations based on individual saved artworks
            const recommendations = [];
            const seenIds = new Set(userSavesCache ? userSavesCache.map(s => `${s.source}-${s.artwork_id}`) : []);

            // Try collaborative filtering first if we have saves
            if (userSavesCache && userSavesCache.length > 0) {
                const shuffledSaves = [...userSavesCache].sort(() => Math.random() - 0.5).slice(0, 5);

                for (const save of shuffledSaves) {
                    try {
                        const { data, error } = await supabaseClient.rpc('get_artwork_recommendations', {
                            p_artwork_id: save.artwork_id,
                            p_source: save.source,
                            p_limit: 20
                        });

                        if (!error && data) {
                            for (const item of data) {
                                const key = `${item.source}-${item.artwork_id}`;
                                if (!seenIds.has(key)) {
                                    seenIds.add(key);
                                    recommendations.push({
                                        uniqueId: item.artwork_id,
                                        id: item.artwork_id,
                                        source: item.source,
                                        title: item.title || 'Untitled',
                                        artist: item.artist || 'Unknown Artist',
                                        date: item.date_created,
                                        medium: item.medium,
                                        imageUrl: item.image_url,
                                        thumbnailUrl: item.thumbnail_url || item.image_url,
                                        sourceUrl: item.source_url,
                                        repository: getSourceDisplayName(item.source)
                                    });
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Fallback recommendation fetch error:', e);
                    }
                }
            }

            // If not enough algorithmic results, supplement with explore artworks
            const minResults = 50;
            if (recommendations.length < minResults) {
                const exploreArtworks = await fetchExploreArtworksForFallback(minResults - recommendations.length, seenIds);
                recommendations.push(...exploreArtworks);
            }

            // Shuffle to mix recommendations from different sources
            return recommendations.sort(() => Math.random() - 0.5);
        }

        async function fetchExploreArtworksForFallback(count, excludeIds) {
            const artworks = [];
            const sources = ['aic', 'met', 'cleveland', 'wikimedia'].filter(s => apiAvailability[s] !== false);
            console.log('fetchExploreArtworksForFallback - available sources:', sources, 'apiAvailability:', apiAvailability);

            // If no sources available, return empty
            if (sources.length === 0) {
                console.log('No sources available for fallback');
                return artworks;
            }

            const fetchesPerSource = Math.ceil(count / sources.length) + 2;

            // Fetch from all available sources in parallel
            const fetchPromises = sources.map(async (source) => {
                try {
                    switch (source) {
                        case 'aic': return await fetchAICArtworks(fetchesPerSource);
                        case 'met': return await fetchMetArtworks(fetchesPerSource);
                        case 'cleveland': return await fetchClevelandArtworks(fetchesPerSource);
                        case 'wikimedia': return await fetchWikimediaArtworks(fetchesPerSource);
                        default: return [];
                    }
                } catch (e) {
                    console.warn(`Failed to fetch from ${source}:`, e);
                    return [];
                }
            });

            try {
                const results = await Promise.all(fetchPromises);

                // Flatten and filter
                for (const sourceResults of results) {
                    for (const art of (sourceResults || [])) {
                        if (!art) continue;
                        const key = `${art.source}-${art.uniqueId || art.id}`;
                        if (!excludeIds.has(key) && artworks.length < count) {
                            excludeIds.add(key);
                            artworks.push(art);
                        }
                    }
                }
            } catch (e) {
                console.warn('Error in fetchExploreArtworksForFallback:', e);
            }

            return artworks;
        }

        async function fetchMoreForYouRecommendations() {
            // Get more recommendations based on what the user has saved
            // This runs in the background to refill the buffer
            try {
                let moreRecs = await fetchFallbackRecommendations();

                // Filter and add to buffer
                let addedCount = 0;
                for (const art of moreRecs) {
                    const key = `${art.source}-${art.uniqueId}`;
                    if (!state.forYouSeenIds.has(key)) {
                        state.forYouSeenIds.add(key);
                        state.forYouBuffer.push(art);
                        addedCount++;
                    }
                }

                // If not enough new items, fetch more explore artworks
                if (addedCount < 20) {
                    const exploreArtworks = await fetchExploreArtworksForFallback(30, state.forYouSeenIds);
                    for (const art of exploreArtworks) {
                        const key = `${art.source}-${art.uniqueId}`;
                        if (!state.forYouSeenIds.has(key)) {
                            state.forYouSeenIds.add(key);
                            state.forYouBuffer.push(art);
                        }
                    }
                }
            } catch (error) {
                console.warn('Error fetching more For You recommendations:', error);
                // On error, try to at least get explore artworks
                try {
                    const exploreArtworks = await fetchExploreArtworksForFallback(30, state.forYouSeenIds);
                    for (const art of exploreArtworks) {
                        const key = `${art.source}-${art.uniqueId}`;
                        if (!state.forYouSeenIds.has(key)) {
                            state.forYouSeenIds.add(key);
                            state.forYouBuffer.push(art);
                        }
                    }
                } catch (e) {
                    console.warn('Explore fallback also failed:', e);
                }
            }
        }

        function renderForYouGrid() {
            const grid = document.getElementById('forYouGrid');
            grid.innerHTML = '';
            state.forYouArtworks.forEach(artwork => {
                grid.appendChild(createTile(artwork));
            });
        }

        async function initAuth() {
            // Listen for auth state changes
            supabaseClient.auth.onAuthStateChange(async (event, session) => {
                if (session?.user) {
                    currentUser = session.user;
                    userSavesCache = null;
                    userFoldersCache = null;
                    // Reset For You state on login
                    state.forYouArtworks = [];
                    state.forYouBuffer = [];
                    state.forYouSeenIds = new Set();
                    state.forYouLoaded = false;
                    await fetchUserSaves();
                    updateAuthUI();
                } else {
                    currentUser = null;
                    userSavesCache = null;
                    userFoldersCache = null;
                    // Reset For You state on logout
                    state.forYouArtworks = [];
                    state.forYouBuffer = [];
                    state.forYouSeenIds = new Set();
                    state.forYouLoaded = false;
                    updateAuthUI();
                }
            });

            // Check for existing session
            const { data: { session } } = await supabaseClient.auth.getSession();
            if (session?.user) {
                currentUser = session.user;
                await fetchUserSaves();
                updateAuthUI();
            }

            // Close modals when clicking outside
            document.getElementById('authModal').addEventListener('click', (e) => {
                if (e.target.id === 'authModal') closeAuthModal();
            });
            document.getElementById('settingsModal').addEventListener('click', (e) => {
                if (e.target.id === 'settingsModal') closeSettingsModal();
            });
            document.getElementById('folderModal').addEventListener('click', (e) => {
                if (e.target.id === 'folderModal') closeFolderModal();
            });
            document.getElementById('changePasswordModal').addEventListener('click', (e) => {
                if (e.target.id === 'changePasswordModal') closeChangePasswordModal();
            });
            document.getElementById('logoutModal').addEventListener('click', (e) => {
                if (e.target.id === 'logoutModal') closeLogoutModal();
            });
            document.getElementById('deleteAccountModal').addEventListener('click', (e) => {
                if (e.target.id === 'deleteAccountModal') closeDeleteAccountModal();
            });
            document.getElementById('privacyModal').addEventListener('click', (e) => {
                if (e.target.id === 'privacyModal') closeLegalModal('privacy');
            });
            document.getElementById('termsModal').addEventListener('click', (e) => {
                if (e.target.id === 'termsModal') closeLegalModal('terms');
            });
            // Enter key to create folder
            document.getElementById('newFolderName').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    createFolder();
                }
            });
        }

        // ===== Expanded View Management =====
        let expandedSwipeStartX = 0;
        let expandedSwipeCurrentX = 0;
        let expandedSwipeStartY = 0;
        let expandedSwipeCurrentY = 0;

        function openExpandedView(artwork) {
            state.expandedArtwork = artwork;

            const overlay = document.getElementById('expandedOverlay');
            const image = document.getElementById('expandedImage');
            const imageContainer = document.getElementById('expandedImageContainer');
            const details = document.getElementById('expandedDetails');

            // Set image source - prefer higher resolution imageUrl
            image.src = artwork.imageUrl || artwork.thumbnailUrl;
            image.alt = artwork.title || 'Artwork';

            // Detect image orientation for optional styling
            imageContainer.classList.remove('portrait', 'landscape');
            image.onload = function() {
                if (this.naturalHeight > this.naturalWidth) {
                    imageContainer.classList.add('portrait');
                } else {
                    imageContainer.classList.add('landscape');
                }
            };

            // Handle image load errors - try thumbnail as fallback
            image.onerror = function() {
                if (artwork.thumbnailUrl && this.src !== artwork.thumbnailUrl) {
                    this.src = artwork.thumbnailUrl;
                } else {
                    // Show a placeholder gradient instead of broken image
                    this.style.display = 'none';
                    imageContainer.style.background = 'linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-card) 100%)';
                    imageContainer.style.minHeight = '200px';
                }
            };

            // Populate source badge
            const sourceBadge = document.getElementById('expandedSourceBadge');
            if (artwork.source) {
                sourceBadge.textContent = getSourceDisplayName(artwork.source);
                sourceBadge.href = artwork.sourceUrl || '#';
                sourceBadge.title = `View on ${getSourceDisplayName(artwork.source)}`;
                sourceBadge.style.display = '';
            } else {
                sourceBadge.style.display = 'none';
            }

            // Populate details section
            details.innerHTML = buildExpandedDetails(artwork);

            // Update save button state
            const saveBtn = document.getElementById('expandedSaveBtn');
            if (isArtworkSaved(artwork.uniqueId, artwork.source)) {
                saveBtn.classList.add('saved');
            } else {
                saveBtn.classList.remove('saved');
            }

            // Show overlay
            overlay.classList.add('active');
            document.body.style.overflow = 'hidden';

            // Setup swipe-to-close for mobile
            if (isTouchDevice()) {
                setupSwipeToClose(overlay);
            }

            // Load recommendations
            loadExpandedRightGrid(artwork);
        }

        function buildExpandedDetails(artwork) {
            const artistInfoParts = [];
            if (artwork.artistNationality) {
                artistInfoParts.push(artwork.artistNationality.split(',')[0].trim());
            }
            if (artwork.artistDates) {
                artistInfoParts.push(artwork.artistDates);
            }
            const artistInfoLine = artistInfoParts.join(', ');

            return `
                <div class="placard-title">${escapeHtml(artwork.title || 'Untitled')}</div>
                <div class="placard-artist">${escapeHtml(artwork.artist || 'Unknown Artist')}</div>
                ${artistInfoLine ? `<div class="placard-artist-dates">${escapeHtml(artistInfoLine)}</div>` : ''}

                ${artwork.date ? `
                    <div class="placard-field">
                        <div class="placard-label">Date</div>
                        <div class="placard-value">${escapeHtml(artwork.date)}</div>
                    </div>
                ` : ''}

                ${artwork.medium ? `
                    <div class="placard-field">
                        <div class="placard-label">Medium</div>
                        <div class="placard-value">${escapeHtml(artwork.medium)}</div>
                    </div>
                ` : ''}

                ${artwork.dimensions ? `
                    <div class="placard-field">
                        <div class="placard-label">Dimensions</div>
                        <div class="placard-value">${escapeHtml(artwork.dimensions)}</div>
                    </div>
                ` : ''}

                ${artwork.classification ? `
                    <div class="placard-field">
                        <div class="placard-label">Classification</div>
                        <div class="placard-value">${escapeHtml(artwork.classification)}</div>
                    </div>
                ` : ''}

                ${artwork.culture || artwork.period || artwork.dynasty ? `
                    <div class="placard-field">
                        <div class="placard-label">Period / Culture</div>
                        <div class="placard-value">${[artwork.period, artwork.culture, artwork.dynasty].filter(Boolean).map(escapeHtml).join('  ')}</div>
                    </div>
                ` : ''}

                ${artwork.department ? `
                    <div class="placard-field">
                        <div class="placard-label">Department</div>
                        <div class="placard-value">${escapeHtml(artwork.department)}</div>
                    </div>
                ` : ''}

                ${artwork.description ? `
                    <div class="placard-divider"></div>
                    <div class="placard-field">
                        <div class="placard-description">${escapeHtml(artwork.description.substring(0, 500))}${artwork.description.length > 500 ? '...' : ''}</div>
                    </div>
                ` : ''}

                ${artwork.repository ? `
                    <div class="placard-divider"></div>
                    <div class="placard-field">
                        <div class="placard-label">Location</div>
                        <div class="placard-value">${escapeHtml(artwork.repository)}</div>
                    </div>
                ` : ''}

                ${artwork.creditLine ? `
                    <div class="placard-field">
                        <div class="placard-label">Credit</div>
                        <div class="placard-value">${escapeHtml(artwork.creditLine)}</div>
                    </div>
                ` : ''}

                ${artwork.accessionNumber ? `
                    <div class="placard-field">
                        <div class="placard-label">Accession</div>
                        <div class="placard-value">${escapeHtml(artwork.accessionNumber)}</div>
                    </div>
                ` : ''}

                ${artwork.sourceUrl ? `
                    <a href="${artwork.sourceUrl}" target="_blank" rel="noopener noreferrer" class="placard-source">
                        <svg viewBox="0 0 24 24">
                            <path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/>
                        </svg>
                        View on ${getSourceDisplayName(artwork.source)}
                    </a>
                ` : ''}
            `;
        }

        function closeExpandedView() {
            const overlay = document.getElementById('expandedOverlay');
            const image = document.getElementById('expandedImage');
            const imageContainer = document.getElementById('expandedImageContainer');

            overlay.classList.remove('active');

            // Reset image state
            image.style.display = '';
            imageContainer.style.background = '';
            imageContainer.style.minHeight = '';
            imageContainer.classList.remove('portrait', 'landscape');

            document.body.style.overflow = '';
            state.expandedArtwork = null;
        }

        function setupSwipeToClose(overlay) {
            // Remove old listeners
            overlay.removeEventListener('touchstart', handleSwipeStart);
            overlay.removeEventListener('touchmove', handleSwipeMove);
            overlay.removeEventListener('touchend', handleSwipeEnd);

            // Add new listeners
            overlay.addEventListener('touchstart', handleSwipeStart, { passive: true });
            overlay.addEventListener('touchmove', handleSwipeMove, { passive: true });
            overlay.addEventListener('touchend', handleSwipeEnd, { passive: true });
        }

        function handleSwipeStart(e) {
            expandedSwipeStartX = e.touches[0].clientX;
            expandedSwipeCurrentX = expandedSwipeStartX;
            expandedSwipeStartY = e.touches[0].clientY;
            expandedSwipeCurrentY = expandedSwipeStartY;
        }

        function handleSwipeMove(e) {
            expandedSwipeCurrentX = e.touches[0].clientX;
            expandedSwipeCurrentY = e.touches[0].clientY;
        }

        function handleSwipeEnd(e) {
            const swipeDistanceX = Math.abs(expandedSwipeCurrentX - expandedSwipeStartX);
            const swipeDistanceY = Math.abs(expandedSwipeCurrentY - expandedSwipeStartY);

            // Close if horizontal swipe (left or right) more than 80px and more horizontal than vertical
            if (swipeDistanceX > 80 && swipeDistanceX > swipeDistanceY) {
                closeExpandedView();
            }
        }

        // ===== Tab Swipe Navigation (Mobile) =====
        let tabSwipeStartX = 0;
        let tabSwipeCurrentX = 0;
        let tabSwipeStartY = 0;
        let tabSwipeCurrentY = 0;

        // Dynamic tab order based on login state
        function getTabOrder() {
            return currentUser
                ? ['explore', 'foryou', 'search', 'saved']
                : ['explore', 'search', 'saved'];
        }

        function initTabSwipeNavigation() {
            const mainContent = document.querySelector('main');
            if (!mainContent) return;

            mainContent.addEventListener('touchstart', handleTabSwipeStart, { passive: true });
            mainContent.addEventListener('touchmove', handleTabSwipeMove, { passive: true });
            mainContent.addEventListener('touchend', handleTabSwipeEnd, { passive: true });
        }

        function handleTabSwipeStart(e) {
            // Don't handle swipes if expanded view is open
            if (document.getElementById('expandedOverlay').classList.contains('active')) return;

            tabSwipeStartX = e.touches[0].clientX;
            tabSwipeCurrentX = tabSwipeStartX;
            tabSwipeStartY = e.touches[0].clientY;
            tabSwipeCurrentY = tabSwipeStartY;
        }

        function handleTabSwipeMove(e) {
            tabSwipeCurrentX = e.touches[0].clientX;
            tabSwipeCurrentY = e.touches[0].clientY;
        }

        function handleTabSwipeEnd(e) {
            // Don't handle swipes if expanded view is open
            if (document.getElementById('expandedOverlay').classList.contains('active')) return;

            const swipeDistanceX = tabSwipeStartX - tabSwipeCurrentX;
            const swipeDistanceY = Math.abs(tabSwipeStartY - tabSwipeCurrentY);

            // Only trigger if:
            // 1. Horizontal swipe is significant (> 100px)
            // 2. Horizontal movement is at least 2x the vertical movement (clearly a horizontal swipe)
            // 3. Vertical movement is less than 50px (not scrolling)
            if (Math.abs(swipeDistanceX) > 100 &&
                Math.abs(swipeDistanceX) > swipeDistanceY * 2 &&
                swipeDistanceY < 50) {
                const tabOrder = getTabOrder();
                const currentIndex = tabOrder.indexOf(state.currentTab);

                if (swipeDistanceX > 0) {
                    // Swiped left - go to next tab
                    if (currentIndex < tabOrder.length - 1) {
                        switchTab(tabOrder[currentIndex + 1]);
                    }
                } else {
                    // Swiped right - go to previous tab
                    if (currentIndex > 0) {
                        switchTab(tabOrder[currentIndex - 1]);
                    }
                }
            }
        }

        function initExpandedViewListeners() {
            const overlay = document.getElementById('expandedOverlay');
            const closeBtn = document.getElementById('expandedCloseBtn');
            const downloadBtn = document.getElementById('expandedDownloadBtn');
            const container = document.querySelector('.expanded-container');

            // Close button
            closeBtn.addEventListener('click', closeExpandedView);

            // Prevent clicks inside container from closing
            container.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            // Click outside (on overlay background) to close
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeExpandedView();
                }
            });

            // Download button in expanded view
            downloadBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (state.expandedArtwork && !downloadBtn.classList.contains('downloading')) {
                    await downloadArtwork(state.expandedArtwork, e, downloadBtn);
                }
            });

            // Save button in expanded view
            const saveBtn = document.getElementById('expandedSaveBtn');
            saveBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (!state.expandedArtwork) return;

                const isSaved = saveBtn.classList.contains('saved');
                if (isSaved) {
                    const artworkId = state.expandedArtwork.uniqueId || state.expandedArtwork.id;
                    const success = await unsaveArtwork(artworkId, state.expandedArtwork.source);
                    if (success) saveBtn.classList.remove('saved');
                } else {
                    const success = await saveArtwork(state.expandedArtwork);
                    if (success) saveBtn.classList.add('saved');
                }
            });

            // Escape key to close
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && state.expandedArtwork) {
                    closeExpandedView();
                }
            });

            // Infinite scroll for expanded right grid (same trigger point as Explore)
            const rightGrid = document.getElementById('expandedRightGrid');
            rightGrid.addEventListener('scroll', () => {
                if (state.expandedArtwork && !state.isLoadingMoreExpandedGrid) {
                    const { scrollTop, scrollHeight, clientHeight } = rightGrid;
                    // Trigger earlier (800px from bottom) for smoother experience
                    if (scrollTop + clientHeight >= scrollHeight - 800) {
                        loadMoreExpandedGridArtworks();
                    }
                }
            });

            // Also listen for scroll on the expanded overlay itself (for mobile)
            const expandedOverlay = document.getElementById('expandedOverlay');
            expandedOverlay.addEventListener('scroll', () => {
                if (state.expandedArtwork && !state.isLoadingMoreExpandedGrid) {
                    const { scrollTop, scrollHeight, clientHeight } = expandedOverlay;
                    if (scrollTop + clientHeight >= scrollHeight - 800) {
                        loadMoreExpandedGridArtworks();
                    }
                }
            });
        }

        // ===== Constants =====
        const MET_API_BASE = 'https://collectionapi.metmuseum.org/public/collection/v1';
        const WIKIMEDIA_API_BASE = 'https://commons.wikimedia.org/w/api.php';
        const AIC_API_BASE = 'https://api.artic.edu/api/v1'; // Art Institute of Chicago
        const AIC_IMAGE_BASE = 'https://www.artic.edu/iiif/2';
        const CLEVELAND_API_BASE = 'https://openaccess-api.clevelandart.org/api'; // Cleveland Museum of Art
        const BATCH_SIZE = 30; // Larger batches for smoother scrolling

        // ===== Rate Limit Protection =====
        const PARALLEL_REQUESTS = 8; // Max parallel requests
        const BATCH_DELAY_MS = 200; // Delay between batches
        const CACHE_PREFIX = 'chiron_cache_';
        const CACHE_EXPIRY_HOURS = 24; // Cache expires after 24 hours
        let currentBackoffMs = 0; // Current backoff delay (exponential)
        const MAX_BACKOFF_MS = 8000; // Max 8 second backoff

        // Track API availability for fallback
        const apiAvailability = {
            met: true,
            aic: true,      // Art Institute of Chicago
            cleveland: true, // Cleveland Museum of Art
            wikimedia: true
        };

        // LocalStorage cache helpers
        function getCachedData(key) {
            try {
                const cached = localStorage.getItem(CACHE_PREFIX + key);
                if (!cached) return null;

                const { data, timestamp } = JSON.parse(cached);
                const ageHours = (Date.now() - timestamp) / (1000 * 60 * 60);

                if (ageHours > CACHE_EXPIRY_HOURS) {
                    localStorage.removeItem(CACHE_PREFIX + key);
                    return null;
                }
                return data;
            } catch (e) {
                return null;
            }
        }

        function setCachedData(key, data) {
            try {
                const cacheEntry = {
                    data,
                    timestamp: Date.now()
                };
                localStorage.setItem(CACHE_PREFIX + key, JSON.stringify(cacheEntry));
            } catch (e) {
                // LocalStorage might be full - clear old cache entries
                clearOldCache();
                try {
                    localStorage.setItem(CACHE_PREFIX + key, JSON.stringify({ data, timestamp: Date.now() }));
                } catch (e2) {
                    // Still failed, ignore
                }
            }
        }

        function clearOldCache() {
            try {
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(CACHE_PREFIX)) {
                        try {
                            const { timestamp } = JSON.parse(localStorage.getItem(key));
                            const ageHours = (Date.now() - timestamp) / (1000 * 60 * 60);
                            if (ageHours > CACHE_EXPIRY_HOURS) {
                                keysToRemove.push(key);
                            }
                        } catch (e) {
                            keysToRemove.push(key);
                        }
                    }
                }
                keysToRemove.forEach(key => localStorage.removeItem(key));
            } catch (e) {
                // Ignore errors
            }
        }

        // One-time clear of AIC cache to force fresh URLs (v2 update)
        function clearAICCache() {
            const cacheVersion = localStorage.getItem('chiron_aic_cache_version');
            if (cacheVersion !== '2') {
                try {
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith(CACHE_PREFIX) && key.includes('aic')) {
                            keysToRemove.push(key);
                        }
                    }
                    keysToRemove.forEach(key => localStorage.removeItem(key));
                    localStorage.setItem('chiron_aic_cache_version', '2');
                } catch (e) {
                    // Ignore errors
                }
            }
        }

        // Clear AIC cache on load
        clearAICCache();

        // Fetch with exponential backoff and caching
        async function fetchWithBackoff(url, cacheKey = null) {
            // Check cache first
            if (cacheKey) {
                const cached = getCachedData(cacheKey);
                if (cached) {
                    return cached;
                }
            }

            // Apply current backoff if any
            if (currentBackoffMs > 0) {
                await new Promise(r => setTimeout(r, currentBackoffMs));
            }

            let lastError;
            let backoff = 2000; // Start with 2 seconds

            for (let attempt = 0; attempt < 4; attempt++) {
                try {
                    const response = await fetch(url);

                    if (response.status === 429) {
                        // Rate limited - apply exponential backoff
                        console.warn(`Rate limited, backing off for ${backoff}ms`);
                        currentBackoffMs = Math.min(backoff, MAX_BACKOFF_MS);
                        await new Promise(r => setTimeout(r, backoff));
                        backoff *= 2; // Double for next attempt
                        continue;
                    }

                    // 404/403 means resource doesn't exist or is forbidden - don't retry
                    if (response.status === 404 || response.status === 403) {
                        throw new Error(`HTTP ${response.status} - not retrying`);
                    }

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    // Success - reset backoff and cache result
                    currentBackoffMs = Math.max(0, currentBackoffMs - 500); // Gradually reduce backoff
                    const data = await response.json();

                    if (cacheKey) {
                        setCachedData(cacheKey, data);
                    }

                    return data;
                } catch (error) {
                    lastError = error;
                    // Don't retry on 404/403 - these won't succeed on retry
                    if (error.message && (error.message.includes('404') || error.message.includes('403'))) {
                        throw error;
                    }
                    if (attempt < 3) {
                        await new Promise(r => setTimeout(r, backoff));
                        backoff *= 2;
                    }
                }
            }

            throw lastError || new Error('Fetch failed after retries');
        }

        // Delay helper
        function delay(ms) {
            return new Promise(r => setTimeout(r, ms));
        }

        // Loading phrases for the scroll indicator
        const LOADING_PHRASES = [
            "The gallery doors are opening",
            "Nature likes to hide... but not for long",
            "Dusting off the collection",
            "The muses are gathering",
            "Summoning beauty from the archives",
            "The ancients await your gaze",
            "Canvases unfurling",
            "Pigments blending",
            "Shadows giving way to form",
            "Treasures surfacing"
        ];

        let lastLoadingPhrase = '';

        function getRandomLoadingPhrase() {
            // Get a different phrase than last time
            const availablePhrases = LOADING_PHRASES.filter(p => p !== lastLoadingPhrase);
            const phrase = availablePhrases[Math.floor(Math.random() * availablePhrases.length)];
            lastLoadingPhrase = phrase;
            return phrase;
        }

        // Fine art department IDs from Met Museum (excludes Modern Art to reduce contemporary pieces)
        const MET_DEPARTMENTS = [
            11, // European Paintings
            9,  // Drawings and Prints
            6,  // Asian Art
            14, // Islamic Art
            3,  // Ancient Near Eastern Art
            5,  // Arts of Africa, Oceania, and the Americas
            15, // Medieval Art
            17, // Photographs - Met's curated photography collection
            // 21, // Modern Art - excluded to reduce contemporary pieces
        ];

        // Medium mappings for search
        const MEDIUM_KEYWORDS = {
            'paintings': ['painting', 'oil on canvas', 'oil on panel', 'tempera', 'acrylic'],
            'drawings': ['drawing', 'pencil', 'charcoal', 'chalk', 'graphite', 'sketch'],
            'prints': ['print', 'lithograph', 'screenprint', 'silkscreen', 'monotype'],
            'etchings': ['etching', 'engraving', 'aquatint', 'drypoint', 'mezzotint'],
            'woodcuts': ['woodcut', 'woodblock', 'wood engraving', 'ukiyo-e'],
            'photographs': ['photograph', 'photography', 'gelatin silver', 'daguerreotype', 'albumen'],
            'watercolors': ['watercolor', 'gouache', 'wash']
        };

        // Period date ranges
        const PERIOD_RANGES = {
            'ancient': { start: -5000, end: 500 },
            'medieval': { start: 500, end: 1400 },
            '15th': { start: 1400, end: 1500 },
            '16th': { start: 1500, end: 1600 },
            '17th': { start: 1600, end: 1700 },
            '18th': { start: 1700, end: 1800 },
            '19th': { start: 1800, end: 1900 },
            '20th': { start: 1900, end: 2000 }
        };

        // Helper function to check if artwork matches period filter
        // Works with single year, year range (beginYear/endYear), or date string
        function matchesPeriodFilter(filters, options = {}) {
            const { year, beginYear, endYear, dateStr } = options;

            // No period filter selected - everything matches
            if (!filters.period || filters.period === '' || !PERIOD_RANGES[filters.period]) {
                return true;
            }

            const range = PERIOD_RANGES[filters.period];

            // If we have begin/end years, check for overlap
            if (typeof beginYear === 'number' && typeof endYear === 'number') {
                return !(endYear < range.start || beginYear > range.end);
            }

            // If we have a single year
            if (typeof year === 'number') {
                return year >= range.start && year <= range.end;
            }

            // Try to extract year from date string
            if (dateStr) {
                const extractedYear = extractYear(dateStr);
                if (extractedYear !== null) {
                    return extractedYear >= range.start && extractedYear <= range.end;
                }
            }

            // Can't determine date - exclude when period filter is active
            return false;
        }

        // ===== Toast Notifications =====
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        // ===== Theme Toggle =====
        function initTheme() {
            const savedTheme = localStorage.getItem('artium_theme');
            if (savedTheme === 'light') {
                state.darkMode = false;
                document.documentElement.classList.add('light');
                updateThemeIcon();
            }
        }

        function toggleTheme() {
            state.darkMode = !state.darkMode;
            document.documentElement.classList.toggle('light');
            localStorage.setItem('artium_theme', state.darkMode ? 'dark' : 'light');
            updateThemeIcon();
        }

        function updateThemeIcon() {
            const sunIcon = document.querySelector('.sun-icon');
            const moonIcon = document.querySelector('.moon-icon');
            if (state.darkMode) {
                sunIcon.style.display = 'none';
                moonIcon.style.display = 'block';
            } else {
                sunIcon.style.display = 'block';
                moonIcon.style.display = 'none';
            }
        }

        // ===== Tab Navigation =====
        function switchTab(tabName) {
            state.currentTab = tabName;
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.toggle('active', content.id === tabName + 'Tab');
            });

            // Manage background fetching based on tab
            if (tabName === 'explore') {
                // Resume background fetching for explore
                if (!bufferFetchInterval) {
                    startBackgroundFetching();
                }
                // Stop search fetching
                stopSearchBufferFetching();
            } else if (tabName === 'search') {
                // Stop explore fetching
                stopBackgroundFetching();
                // Resume search fetching if there's an active search
                if (state.currentSearchQuery && state.searchArtworks.length > 0 && !searchBufferFetchInterval) {
                    startSearchBufferFetching();
                }
            } else {
                // Pause all background fetching on other tabs
                stopBackgroundFetching();
                stopSearchBufferFetching();
            }

            // Update buffer indicator for new tab
            updateBufferIndicator();

            if (tabName === 'saved') {
                // Reset to folder list view when navigating to saved tab
                currentViewingFolder = null;
                renderSavedGrid();
            }

            if (tabName === 'foryou') {
                // Load For You recommendations if not already loaded
                if (!state.forYouLoaded) {
                    loadForYouRecommendations();
                }
            }
        }

        // ===== API Functions =====

        // Extended random search terms for maximum variety
        const RANDOM_SEARCH_TERMS = [
            // People & Portraits
            'portrait', 'woman', 'man', 'mother', 'child', 'family', 'nude',
            'self portrait', 'king', 'queen', 'nobleman', 'peasant', 'noble',
            'elderly', 'youth', 'couple', 'group portrait', 'figure',
            // Nature & Landscapes
            'landscape', 'nature', 'flowers', 'sea', 'mountain', 'forest',
            'garden', 'river', 'sunset', 'night', 'winter', 'summer', 'spring',
            'autumn', 'storm', 'sky', 'clouds', 'trees', 'meadow', 'field',
            'coast', 'cliff', 'waterfall', 'lake', 'pond', 'snow', 'rain',
            // Animals
            'horse', 'dog', 'cat', 'bird', 'lion', 'deer', 'cattle', 'sheep',
            // Subjects & Themes
            'still life', 'religious', 'mythology', 'battle', 'dance', 'music',
            'reading', 'saint', 'angel', 'virgin', 'christ', 'madonna',
            'crucifixion', 'annunciation', 'nativity', 'resurrection',
            'hunting', 'fishing', 'harvest', 'feast', 'banquet', 'wedding',
            'death', 'love', 'allegory', 'vanitas', 'fruit', 'wine',
            // Places & Architecture
            'city', 'village', 'castle', 'church', 'ruins', 'interior',
            'palace', 'market', 'harbor', 'bridge', 'street', 'tavern',
            // Movements & Styles
            'classical', 'romantic', 'pastoral', 'biblical', 'historical',
            'oriental', 'exotic', 'domestic', 'scene', 'view'
        ];

        // Synonym expansion for common search terms (includes translations for international art)
        const SEARCH_SYNONYMS = {
            // ===== NATURE - TREES & PLANTS =====
            'tree': ['trees', 'forest', 'woodland', 'woods', 'oak', 'pine', 'birch', 'willow', 'cypress', 'elm', 'maple', 'arbre', 'wald', 'baum', 'albero', 'arbol'],
            'trees': ['tree', 'forest', 'woodland', 'woods', 'grove', 'orchard', 'arbres', 'baume', 'alberi'],
            'forest': ['trees', 'woodland', 'woods', 'grove', 'jungle', 'thicket', 'wald', 'foret', 'bosque', 'foresta', 'selva', 'sylvan'],
            'woods': ['forest', 'woodland', 'trees', 'grove', 'thicket', 'bois', 'wald', 'bosco'],
            'oak': ['tree', 'trees', 'forest', 'chene', 'eiche', 'quercia', 'roble'],
            'pine': ['tree', 'trees', 'evergreen', 'conifer', 'pin', 'kiefer', 'pino'],
            'palm': ['palms', 'tropical', 'palmier', 'palme', 'palma'],
            'flower': ['flowers', 'floral', 'bouquet', 'blossom', 'bloom', 'petal', 'fleur', 'blume', 'fiore', 'flor', 'bloem'],
            'flowers': ['flower', 'floral', 'bouquet', 'blossoms', 'blooms', 'petals', 'botanical', 'fleurs', 'blumen', 'fiori', 'flores'],
            'rose': ['roses', 'flower', 'floral', 'rosa', 'rosen'],
            'roses': ['rose', 'flowers', 'floral', 'bouquet', 'rosen', 'rose'],
            'tulip': ['tulips', 'flower', 'flowers', 'dutch', 'tulipe', 'tulpe', 'tulipano'],
            'tulips': ['tulip', 'flowers', 'dutch', 'floral', 'tulipes', 'tulpen'],
            'lily': ['lilies', 'flower', 'flowers', 'lis', 'lilie', 'giglio', 'lirio'],
            'lilies': ['lily', 'flowers', 'floral', 'lilien', 'gigli'],
            'sunflower': ['sunflowers', 'flower', 'tournesol', 'sonnenblume', 'girasole', 'girasol'],
            'iris': ['irises', 'flower', 'flowers', 'schwertlilie'],
            'orchid': ['orchids', 'flower', 'tropical', 'orchidee', 'orchidea'],
            'poppy': ['poppies', 'flower', 'flowers', 'red', 'coquelicot', 'mohn', 'papavero', 'amapola'],
            'garden': ['gardens', 'jardin', 'garten', 'giardino', 'floral', 'flowers', 'botanical', 'park', 'hortus'],
            'botanical': ['flowers', 'plants', 'garden', 'flora', 'botanique', 'botanisch'],
            'bouquet': ['flowers', 'floral', 'vase', 'arrangement', 'blumenstrauss'],
            'vine': ['vines', 'grape', 'vineyard', 'vigne', 'rebe', 'vite', 'vid'],
            'leaf': ['leaves', 'foliage', 'feuille', 'blatt', 'foglia', 'hoja'],
            'leaves': ['leaf', 'foliage', 'autumn', 'fall', 'feuilles', 'blatter', 'foglie'],

            // ===== NATURE - WATER =====
            'sea': ['ocean', 'marine', 'maritime', 'seascape', 'waves', 'coast', 'mer', 'meer', 'mare', 'mar', 'zee'],
            'ocean': ['sea', 'marine', 'maritime', 'seascape', 'waves', 'pacific', 'atlantic', 'mer', 'ozean', 'oceano'],
            'wave': ['waves', 'sea', 'ocean', 'surf', 'water', 'breaker', 'vague', 'welle', 'onda', 'ola'],
            'waves': ['wave', 'sea', 'ocean', 'surf', 'water', 'marine', 'stormy', 'vagues', 'wellen', 'onde'],
            'river': ['rivers', 'stream', 'creek', 'brook', 'riviere', 'fluss', 'fiume', 'rio', 'rivier'],
            'stream': ['river', 'creek', 'brook', 'water', 'ruisseau', 'bach', 'ruscello'],
            'water': ['river', 'lake', 'sea', 'pond', 'stream', 'aquatic', 'eau', 'wasser', 'acqua', 'agua', 'water'],
            'lake': ['lakes', 'pond', 'water', 'lac', 'see', 'lago'],
            'pond': ['lake', 'water', 'pool', 'etang', 'teich', 'stagno', 'estanque'],
            'waterfall': ['waterfalls', 'cascade', 'falls', 'chute', 'wasserfall', 'cascata', 'cascada'],
            'fountain': ['fountains', 'water', 'fontaine', 'brunnen', 'fontana', 'fuente'],
            'rain': ['rainy', 'storm', 'weather', 'pluie', 'regen', 'pioggia', 'lluvia'],
            'storm': ['stormy', 'tempest', 'thunder', 'lightning', 'tempete', 'sturm', 'tempesta', 'tormenta'],
            'coast': ['coastal', 'shore', 'beach', 'seaside', 'cote', 'kuste', 'costa'],
            'beach': ['shore', 'coast', 'sand', 'seaside', 'plage', 'strand', 'spiaggia', 'playa'],
            'shore': ['beach', 'coast', 'seaside', 'riverbank', 'rivage', 'ufer', 'riva', 'orilla'],
            'ship': ['ships', 'boat', 'vessel', 'sailing', 'navire', 'schiff', 'nave', 'barco'],
            'boat': ['boats', 'ship', 'vessel', 'sailing', 'canoe', 'bateau', 'boot', 'barca'],
            'sailing': ['sail', 'ship', 'boat', 'maritime', 'voile', 'segeln', 'vela'],

            // ===== NATURE - LAND & SKY =====
            'mountain': ['mountains', 'alpine', 'peaks', 'summit', 'montagne', 'berg', 'montagna', 'montana', 'gebirge'],
            'mountains': ['mountain', 'alpine', 'peaks', 'hills', 'montagnes', 'berge', 'montagne'],
            'hill': ['hills', 'mountain', 'slope', 'colline', 'hugel', 'collina', 'colina'],
            'hills': ['hill', 'mountains', 'rolling', 'collines', 'hugel', 'colline'],
            'valley': ['valleys', 'glen', 'dale', 'vallee', 'tal', 'valle'],
            'cliff': ['cliffs', 'rock', 'precipice', 'falaise', 'klippe', 'scogliera', 'acantilado'],
            'rock': ['rocks', 'stone', 'boulder', 'rocky', 'rocher', 'felsen', 'roccia', 'roca'],
            'cave': ['caves', 'cavern', 'grotto', 'grotte', 'hohle', 'grotta', 'cueva'],
            'landscape': ['landscapes', 'scenery', 'vista', 'view', 'countryside', 'paysage', 'landschaft', 'paesaggio', 'paisaje'],
            'countryside': ['landscape', 'rural', 'pastoral', 'campagne', 'landschaft', 'campagna'],
            'field': ['fields', 'meadow', 'prairie', 'pasture', 'farmland', 'champ', 'feld', 'campo'],
            'meadow': ['meadows', 'field', 'pasture', 'prairie', 'grassland', 'pre', 'wiese', 'prato', 'pradera'],
            'prairie': ['meadow', 'grassland', 'plain', 'steppe', 'savanna'],
            'desert': ['deserts', 'sand', 'dunes', 'arid', 'desert', 'wuste', 'deserto', 'desierto'],
            'island': ['islands', 'isle', 'tropical', 'ile', 'insel', 'isola', 'isla'],
            'sky': ['skies', 'clouds', 'heavens', 'atmosphere', 'ciel', 'himmel', 'cielo'],
            'cloud': ['clouds', 'sky', 'cumulus', 'nuage', 'wolke', 'nuvola', 'nube'],
            'clouds': ['cloud', 'sky', 'heavens', 'nuages', 'wolken', 'nuvole', 'nubes'],
            'sun': ['sunny', 'sunlight', 'solar', 'soleil', 'sonne', 'sole', 'sol'],
            'moon': ['lunar', 'moonlight', 'crescent', 'lune', 'mond', 'luna'],
            'star': ['stars', 'stellar', 'celestial', 'etoile', 'stern', 'stella', 'estrella'],
            'stars': ['star', 'night', 'celestial', 'constellation', 'etoiles', 'sterne', 'stelle'],
            'night': ['nocturne', 'nighttime', 'evening', 'dark', 'nuit', 'nacht', 'notte', 'noche'],
            'sunset': ['dusk', 'twilight', 'evening', 'sundown', 'coucher de soleil', 'sonnenuntergang', 'tramonto', 'puesta de sol'],
            'sunrise': ['dawn', 'morning', 'daybreak', 'lever du soleil', 'sonnenaufgang', 'alba'],
            'dawn': ['sunrise', 'morning', 'daybreak', 'aube', 'morgendammerung', 'alba'],
            'dusk': ['twilight', 'evening', 'sunset', 'crepuscule', 'dammerung', 'crepuscolo'],

            // ===== SEASONS & WEATHER =====
            'spring': ['springtime', 'vernal', 'bloom', 'printemps', 'fruhling', 'primavera'],
            'summer': ['summertime', 'warm', 'sunny', 'ete', 'sommer', 'estate', 'verano'],
            'autumn': ['fall', 'autumnal', 'harvest', 'automne', 'herbst', 'autunno', 'otono'],
            'fall': ['autumn', 'autumnal', 'harvest', 'leaves', 'automne', 'herbst'],
            'winter': ['snow', 'cold', 'ice', 'frost', 'hiver', 'winter', 'inverno', 'invierno'],
            'snow': ['snowy', 'winter', 'frost', 'ice', 'blizzard', 'neige', 'schnee', 'neve', 'nieve'],
            'ice': ['icy', 'frozen', 'frost', 'winter', 'glace', 'eis', 'ghiaccio', 'hielo'],
            'frost': ['frozen', 'ice', 'winter', 'cold', 'gelee', 'frost', 'gelo', 'escarcha'],
            'fog': ['mist', 'misty', 'haze', 'brouillard', 'nebel', 'nebbia', 'niebla'],
            'mist': ['fog', 'misty', 'haze', 'brume', 'dunst', 'foschia'],

            // ===== ANIMALS =====
            'horse': ['horses', 'equestrian', 'equine', 'stallion', 'mare', 'foal', 'pony', 'cheval', 'pferd', 'cavallo', 'caballo'],
            'horses': ['horse', 'equestrian', 'cavalry', 'chevaux', 'pferde', 'cavalli', 'caballos'],
            'dog': ['dogs', 'canine', 'hound', 'puppy', 'terrier', 'spaniel', 'chien', 'hund', 'cane', 'perro'],
            'dogs': ['dog', 'canine', 'hounds', 'hunting', 'chiens', 'hunde', 'cani', 'perros'],
            'cat': ['cats', 'feline', 'kitten', 'tabby', 'chat', 'katze', 'gatto', 'gato'],
            'cats': ['cat', 'feline', 'kittens', 'chats', 'katzen', 'gatti', 'gatos'],
            'bird': ['birds', 'avian', 'fowl', 'songbird', 'oiseau', 'vogel', 'uccello', 'pajaro'],
            'birds': ['bird', 'avian', 'flock', 'oiseaux', 'vogel', 'uccelli', 'pajaros'],
            'eagle': ['eagles', 'bird', 'raptor', 'aigle', 'adler', 'aquila', 'aguila'],
            'hawk': ['hawks', 'falcon', 'bird', 'raptor', 'faucon', 'falke', 'falco', 'halcon'],
            'owl': ['owls', 'bird', 'nocturnal', 'hibou', 'eule', 'gufo', 'buho'],
            'swan': ['swans', 'bird', 'water', 'cygne', 'schwan', 'cigno', 'cisne'],
            'peacock': ['peacocks', 'bird', 'feathers', 'paon', 'pfau', 'pavone', 'pavo'],
            'dove': ['doves', 'pigeon', 'bird', 'peace', 'colombe', 'taube', 'colomba', 'paloma'],
            'rooster': ['cock', 'chicken', 'bird', 'coq', 'hahn', 'gallo'],
            'lion': ['lions', 'leonine', 'feline', 'king', 'leo', 'lowe', 'leone', 'leon'],
            'tiger': ['tigers', 'feline', 'striped', 'tigre', 'tiger'],
            'leopard': ['leopards', 'feline', 'spotted', 'panther', 'leopard', 'leopardo'],
            'deer': ['stag', 'doe', 'fawn', 'hart', 'cerf', 'hirsch', 'cervo', 'ciervo'],
            'stag': ['deer', 'hart', 'buck', 'antlers', 'cerf', 'hirsch'],
            'bear': ['bears', 'ursine', 'ours', 'bar', 'orso', 'oso'],
            'wolf': ['wolves', 'canine', 'loup', 'wolf', 'lupo', 'lobo'],
            'fox': ['foxes', 'vulpine', 'renard', 'fuchs', 'volpe', 'zorro'],
            'rabbit': ['rabbits', 'hare', 'bunny', 'lapin', 'hase', 'coniglio', 'conejo'],
            'sheep': ['lamb', 'flock', 'pastoral', 'mouton', 'schaf', 'pecora', 'oveja'],
            'lamb': ['sheep', 'pastoral', 'agneau', 'lamm', 'agnello', 'cordero'],
            'cow': ['cattle', 'bull', 'ox', 'bovine', 'vache', 'kuh', 'vacca', 'vaca'],
            'cattle': ['cow', 'bull', 'ox', 'bovine', 'herd', 'betail', 'vieh', 'bestiame', 'ganado'],
            'bull': ['cattle', 'ox', 'toro', 'taureau', 'stier', 'toro'],
            'goat': ['goats', 'kid', 'chevre', 'ziege', 'capra', 'cabra'],
            'pig': ['pigs', 'swine', 'boar', 'cochon', 'schwein', 'maiale', 'cerdo'],
            'elephant': ['elephants', 'pachyderm', 'elephant', 'elefant', 'elefante'],
            'monkey': ['monkeys', 'ape', 'primate', 'singe', 'affe', 'scimmia', 'mono'],
            'fish': ['fishes', 'aquatic', 'marine', 'poisson', 'fisch', 'pesce', 'pez'],
            'dolphin': ['dolphins', 'marine', 'dauphin', 'delfin', 'delfino'],
            'whale': ['whales', 'marine', 'baleine', 'wal', 'balena', 'ballena'],
            'snake': ['serpent', 'reptile', 'serpent', 'schlange', 'serpente', 'serpiente'],
            'dragon': ['dragons', 'mythical', 'serpent', 'drache', 'drago', 'dragon'],
            'butterfly': ['butterflies', 'insect', 'papillon', 'schmetterling', 'farfalla', 'mariposa'],
            'bee': ['bees', 'insect', 'abeille', 'biene', 'ape', 'abeja'],

            // ===== PEOPLE - GENERAL =====
            'woman': ['women', 'lady', 'female', 'girl', 'maiden', 'femme', 'frau', 'donna', 'mujer', 'vrouw'],
            'women': ['woman', 'ladies', 'female', 'girls', 'femmes', 'frauen', 'donne', 'mujeres'],
            'man': ['men', 'male', 'gentleman', 'homme', 'mann', 'uomo', 'hombre'],
            'men': ['man', 'male', 'gentlemen', 'hommes', 'manner', 'uomini', 'hombres'],
            'girl': ['girls', 'woman', 'maiden', 'young', 'fille', 'madchen', 'ragazza', 'nina'],
            'boy': ['boys', 'youth', 'young', 'garcon', 'junge', 'ragazzo', 'nino'],
            'child': ['children', 'infant', 'baby', 'youth', 'kid', 'enfant', 'kind', 'bambino', 'nino'],
            'children': ['child', 'infants', 'babies', 'youth', 'kids', 'enfants', 'kinder', 'bambini', 'ninos'],
            'baby': ['infant', 'child', 'newborn', 'bebe', 'baby', 'bambino', 'bebe'],
            'infant': ['baby', 'child', 'newborn', 'nourrisson', 'saugling', 'neonato'],
            'family': ['families', 'domestic', 'mother', 'father', 'famille', 'familie', 'famiglia', 'familia'],
            'mother': ['maternal', 'madonna', 'mom', 'mama', 'mere', 'mutter', 'madre'],
            'father': ['paternal', 'dad', 'papa', 'pere', 'vater', 'padre'],
            'couple': ['couples', 'lovers', 'pair', 'romantic', 'paar', 'coppia', 'pareja'],
            'lovers': ['couple', 'love', 'romantic', 'amants', 'liebende', 'amanti', 'amantes'],
            'elderly': ['old', 'aged', 'senior', 'vieux', 'alt', 'anziano', 'anciano'],
            'youth': ['young', 'adolescent', 'teenage', 'jeunesse', 'jugend', 'gioventu', 'juventud'],
            'peasant': ['peasants', 'farmer', 'rural', 'paysan', 'bauer', 'contadino', 'campesino'],
            'farmer': ['farmers', 'peasant', 'agricultural', 'fermier', 'bauer', 'agricoltore', 'granjero'],
            'worker': ['workers', 'laborer', 'working', 'ouvrier', 'arbeiter', 'operaio', 'trabajador'],
            'soldier': ['soldiers', 'military', 'warrior', 'soldat', 'soldat', 'soldato', 'soldado'],
            'knight': ['knights', 'armor', 'chivalry', 'medieval', 'chevalier', 'ritter', 'cavaliere', 'caballero'],
            'king': ['kings', 'royal', 'monarch', 'roi', 'konig', 're', 'rey'],
            'queen': ['queens', 'royal', 'monarch', 'reine', 'konigin', 'regina', 'reina'],
            'prince': ['princes', 'royal', 'nobleman', 'prince', 'prinz', 'principe'],
            'princess': ['princesses', 'royal', 'noblewoman', 'princesse', 'prinzessin', 'principessa'],
            'noble': ['nobleman', 'aristocrat', 'aristocracy', 'nobility', 'adel', 'nobile', 'noble'],
            'aristocrat': ['noble', 'nobleman', 'aristocracy', 'aristocrate', 'aristokrat'],

            // ===== PORTRAITS & FIGURES =====
            'portrait': ['portraits', 'face', 'head', 'bust', 'likeness', 'ritratto', 'retrato', 'bildnis', 'portret'],
            'self portrait': ['self-portrait', 'artist', 'autoportrait', 'selbstbildnis', 'autoritratto', 'autorretrato'],
            'bust': ['busts', 'portrait', 'head', 'sculpture', 'buste', 'buste', 'busto'],
            'head': ['heads', 'portrait', 'face', 'tete', 'kopf', 'testa', 'cabeza'],
            'face': ['faces', 'portrait', 'visage', 'gesicht', 'viso', 'rostro'],
            'figure': ['figures', 'body', 'form', 'human', 'figura', 'figur'],
            'nude': ['nudes', 'naked', 'unclothed', 'nu', 'akt', 'nudo', 'desnudo'],
            'bather': ['bathers', 'bathing', 'nude', 'baigneuse', 'badende'],
            'odalisque': ['harem', 'reclining', 'nude', 'oriental'],

            // ===== RELIGIOUS =====
            'christ': ['jesus', 'christian', 'biblical', 'savior', 'cristo', 'christus', 'gesu'],
            'jesus': ['christ', 'christian', 'biblical', 'savior', 'christ', 'gesu', 'jesus'],
            'madonna': ['virgin', 'mary', 'mother', 'maria', 'vierge', 'maria', 'vergine'],
            'virgin': ['madonna', 'mary', 'maria', 'vierge', 'jungfrau', 'vergine', 'virgen'],
            'mary': ['madonna', 'virgin', 'maria', 'marie', 'maria'],
            'angel': ['angels', 'angelic', 'cherub', 'seraph', 'winged', 'ange', 'engel', 'angelo', 'angel'],
            'angels': ['angel', 'angelic', 'cherubim', 'seraphim', 'anges', 'engel', 'angeli', 'angeles'],
            'cherub': ['cherubs', 'cherubim', 'angel', 'putto', 'putti'],
            'saint': ['saints', 'holy', 'sacred', 'san', 'sant', 'santo', 'santa', 'heilige', 'sint'],
            'apostle': ['apostles', 'disciple', 'biblical', 'apotre', 'apostel', 'apostolo'],
            'prophet': ['prophets', 'biblical', 'prophete', 'prophet', 'profeta'],
            'crucifixion': ['cross', 'christ', 'passion', 'calvary', 'kreuzigung', 'crocifissione', 'crucifixion'],
            'resurrection': ['risen', 'christ', 'easter', 'auferstehung', 'resurrezione', 'resurreccion'],
            'annunciation': ['angel', 'mary', 'gabriel', 'annunciazione', 'anunciacion', 'verkundigung'],
            'nativity': ['birth', 'christ', 'christmas', 'manger', 'nativita', 'natividad', 'geburt'],
            'baptism': ['baptist', 'john', 'river', 'battesimo', 'bautismo', 'taufe'],
            'last supper': ['supper', 'apostles', 'christ', 'cena', 'abendmahl', 'ultima cena'],
            'pieta': ['mary', 'christ', 'lamentation', 'mourning'],
            'holy': ['sacred', 'divine', 'religious', 'saint', 'sacre', 'heilig', 'sacro', 'santo'],
            'sacred': ['holy', 'divine', 'religious', 'sacre', 'heilig', 'sacro', 'sagrado'],
            'biblical': ['bible', 'scripture', 'religious', 'testament', 'biblique', 'biblisch', 'biblico'],
            'religious': ['sacred', 'holy', 'spiritual', 'church', 'religieux', 'religios', 'religioso'],

            // ===== MYTHOLOGY =====
            'mythology': ['mythological', 'myth', 'legend', 'classical', 'mythologie', 'mitologia'],
            'mythological': ['mythology', 'myth', 'classical', 'gods', 'mythologique', 'mitologico'],
            'god': ['gods', 'deity', 'divine', 'olympian', 'dieu', 'gott', 'dio', 'dios'],
            'goddess': ['goddesses', 'deity', 'divine', 'deesse', 'gottin', 'dea', 'diosa'],
            'venus': ['aphrodite', 'goddess', 'love', 'beauty', 'venere'],
            'aphrodite': ['venus', 'goddess', 'love', 'beauty'],
            'mars': ['ares', 'god', 'war', 'marte'],
            'apollo': ['god', 'sun', 'music', 'apollon'],
            'diana': ['artemis', 'goddess', 'hunt', 'moon', 'diane'],
            'artemis': ['diana', 'goddess', 'hunt', 'moon'],
            'neptune': ['poseidon', 'god', 'sea', 'ocean', 'nettuno'],
            'poseidon': ['neptune', 'god', 'sea', 'ocean'],
            'jupiter': ['zeus', 'god', 'king', 'thunder', 'giove'],
            'zeus': ['jupiter', 'god', 'king', 'thunder'],
            'hercules': ['heracles', 'hero', 'strength', 'labors', 'ercole', 'herakles'],
            'bacchus': ['dionysus', 'god', 'wine', 'bacco'],
            'dionysus': ['bacchus', 'god', 'wine'],
            'cupid': ['eros', 'amor', 'love', 'arrow', 'amore', 'cupidon'],
            'nymph': ['nymphs', 'nature', 'mythological', 'nymphe', 'ninfa'],
            'muse': ['muses', 'inspiration', 'arts', 'musa'],
            'satyr': ['satyrs', 'pan', 'faun', 'mythological', 'satyre', 'satiro'],
            'centaur': ['centaurs', 'mythological', 'horse', 'centaure', 'zentaur', 'centauro'],
            'siren': ['sirens', 'mermaid', 'mythological', 'sea', 'sirene'],
            'mermaid': ['mermaids', 'siren', 'sea', 'mythological', 'sirene', 'meerjungfrau'],
            'pegasus': ['winged', 'horse', 'mythological', 'pegase'],
            'phoenix': ['bird', 'mythological', 'fire', 'rebirth', 'fenix'],

            // ===== SUBJECTS & THEMES =====
            'battle': ['war', 'warfare', 'combat', 'military', 'fight', 'bataille', 'schlacht', 'battaglia', 'batalla'],
            'war': ['battle', 'warfare', 'combat', 'military', 'conflict', 'guerre', 'krieg', 'guerra'],
            'victory': ['triumph', 'winning', 'victoire', 'sieg', 'vittoria', 'victoria'],
            'death': ['dying', 'dead', 'mortality', 'demise', 'mort', 'tod', 'morte', 'muerte'],
            'mourning': ['grief', 'sorrow', 'lamentation', 'funeral', 'deuil', 'trauer', 'lutto', 'duelo'],
            'love': ['lovers', 'romantic', 'romance', 'passion', 'amour', 'liebe', 'amore', 'amor'],
            'kiss': ['kissing', 'lovers', 'romantic', 'baiser', 'kuss', 'bacio', 'beso'],
            'wedding': ['marriage', 'bride', 'groom', 'nuptial', 'mariage', 'hochzeit', 'matrimonio', 'boda'],
            'marriage': ['wedding', 'bride', 'groom', 'nuptial', 'mariage', 'ehe', 'matrimonio'],
            'birth': ['nativity', 'newborn', 'baby', 'naissance', 'geburt', 'nascita', 'nacimiento'],
            'dance': ['dancing', 'dancer', 'dancers', 'ballet', 'danse', 'tanz', 'danza', 'baile'],
            'dancer': ['dancers', 'dancing', 'ballet', 'ballerina', 'danseuse', 'tanzerin', 'ballerina'],
            'music': ['musical', 'musician', 'musicians', 'concert', 'musique', 'musik', 'musica'],
            'musician': ['musicians', 'music', 'player', 'musicien', 'musiker', 'musicista', 'musico'],
            'reading': ['reader', 'book', 'literature', 'lecture', 'lesen', 'lettura', 'lectura'],
            'writing': ['writer', 'letter', 'correspondence', 'ecriture', 'schreiben', 'scrittura'],
            'sewing': ['seamstress', 'needle', 'thread', 'couture', 'nahen', 'cucito'],
            'sleeping': ['sleep', 'asleep', 'dreaming', 'sommeil', 'schlaf', 'sonno', 'sueno'],
            'bathing': ['bath', 'bather', 'washing', 'bain', 'bad', 'bagno', 'bano'],
            'hunting': ['hunt', 'hunter', 'chase', 'chasse', 'jagd', 'caccia', 'caza'],
            'fishing': ['fish', 'fisherman', 'angling', 'peche', 'fischen', 'pesca'],
            'harvest': ['harvesting', 'reaping', 'autumn', 'moisson', 'ernte', 'raccolta', 'cosecha'],
            'feast': ['banquet', 'celebration', 'dinner', 'festin', 'fest', 'festa', 'fiesta'],
            'banquet': ['feast', 'dinner', 'celebration', 'banquet', 'bankett', 'banchetto'],
            'picnic': ['outdoor', 'leisure', 'dejeuner', 'picknick'],
            'carnival': ['festival', 'masquerade', 'celebration', 'carnaval', 'karneval', 'carnevale'],
            'masquerade': ['mask', 'carnival', 'ball', 'mascarade', 'maskerade', 'mascherata'],

            // ===== STILL LIFE =====
            'still life': ['nature morte', 'stilleben', 'natura morta', 'bodegon', 'stilleven'],
            'vanitas': ['still life', 'skull', 'mortality', 'memento mori'],
            'fruit': ['fruits', 'apple', 'grapes', 'peach', 'pear', 'obst', 'frutta', 'frutas'],
            'apple': ['apples', 'fruit', 'pomme', 'apfel', 'mela', 'manzana'],
            'grapes': ['grape', 'vineyard', 'wine', 'raisin', 'traube', 'uva'],
            'peach': ['peaches', 'fruit', 'peche', 'pfirsich', 'pesca', 'melocoton'],
            'lemon': ['lemons', 'citrus', 'fruit', 'citron', 'zitrone', 'limone', 'limon'],
            'orange': ['oranges', 'citrus', 'fruit', 'naranja', 'arancia'],
            'wine': ['grapes', 'glass', 'bottle', 'vin', 'wein', 'vino'],
            'bread': ['loaf', 'food', 'pain', 'brot', 'pane', 'pan'],
            'cheese': ['food', 'dairy', 'fromage', 'kase', 'formaggio', 'queso'],
            'meat': ['food', 'butcher', 'viande', 'fleisch', 'carne'],
            'fish': ['food', 'seafood', 'poisson', 'fisch', 'pesce', 'pescado'],
            'oyster': ['oysters', 'seafood', 'shell', 'huitre', 'auster', 'ostrica', 'ostra'],
            'lobster': ['seafood', 'shellfish', 'homard', 'hummer', 'aragosta', 'langosta'],
            'vase': ['vases', 'flowers', 'vessel', 'vase', 'vaso'],
            'pitcher': ['jug', 'vessel', 'cruche', 'krug', 'brocca', 'jarra'],
            'bowl': ['dish', 'vessel', 'bol', 'schale', 'ciotola', 'cuenco'],
            'glass': ['goblet', 'wine', 'crystal', 'verre', 'glas', 'vetro', 'vidrio'],
            'candle': ['candles', 'light', 'flame', 'bougie', 'kerze', 'candela', 'vela'],
            'skull': ['death', 'vanitas', 'mortality', 'crane', 'schadel', 'teschio', 'calavera'],
            'book': ['books', 'reading', 'literature', 'livre', 'buch', 'libro'],
            'letter': ['letters', 'correspondence', 'writing', 'lettre', 'brief', 'lettera', 'carta'],
            'mirror': ['mirrors', 'reflection', 'miroir', 'spiegel', 'specchio', 'espejo'],
            'clock': ['time', 'timepiece', 'horloge', 'uhr', 'orologio', 'reloj'],
            'musical instrument': ['instrument', 'music', 'violin', 'lute', 'instrument'],
            'violin': ['fiddle', 'music', 'instrument', 'violon', 'geige', 'violino'],
            'lute': ['music', 'instrument', 'luth', 'laute', 'liuto', 'laud'],
            'flute': ['music', 'instrument', 'flute', 'flote', 'flauto', 'flauta'],
            'pipe': ['smoking', 'tobacco', 'pipe', 'pfeife', 'pipa'],
            'carpet': ['rug', 'textile', 'oriental', 'tapis', 'teppich', 'tappeto', 'alfombra'],
            'curtain': ['drape', 'fabric', 'rideau', 'vorhang', 'tenda', 'cortina'],
            'tablecloth': ['table', 'fabric', 'nappe', 'tischtuch', 'tovaglia', 'mantel'],

            // ===== ARCHITECTURE & PLACES =====
            'city': ['urban', 'town', 'cityscape', 'metropolis', 'ville', 'stadt', 'citta', 'ciudad'],
            'town': ['city', 'village', 'urban', 'ville', 'stadt', 'citta', 'pueblo'],
            'village': ['town', 'rural', 'hamlet', 'village', 'dorf', 'villaggio', 'aldea'],
            'street': ['streets', 'road', 'avenue', 'rue', 'strasse', 'strada', 'calle'],
            'square': ['plaza', 'piazza', 'public', 'place', 'platz', 'piazza', 'plaza'],
            'market': ['marketplace', 'bazaar', 'merchants', 'marche', 'markt', 'mercato', 'mercado'],
            'church': ['cathedral', 'chapel', 'basilica', 'abbey', 'eglise', 'kirche', 'chiesa', 'iglesia'],
            'cathedral': ['church', 'gothic', 'cathedral', 'cathedrale', 'dom', 'cattedrale', 'catedral'],
            'chapel': ['church', 'religious', 'chapelle', 'kapelle', 'cappella', 'capilla'],
            'monastery': ['abbey', 'convent', 'religious', 'monastere', 'kloster', 'monastero', 'monasterio'],
            'temple': ['temples', 'ancient', 'classical', 'religious', 'tempel', 'tempio', 'templo'],
            'mosque': ['islamic', 'religious', 'mosquee', 'moschee', 'moschea', 'mezquita'],
            'castle': ['palace', 'fortress', 'medieval', 'chateau', 'schloss', 'castello', 'castillo'],
            'palace': ['castle', 'royal', 'residence', 'palais', 'palast', 'palazzo', 'palacio'],
            'fortress': ['castle', 'fort', 'citadel', 'forteresse', 'festung', 'fortezza', 'fortaleza'],
            'tower': ['towers', 'turret', 'spire', 'tour', 'turm', 'torre'],
            'ruins': ['ruin', 'ancient', 'classical', 'ruines', 'ruinen', 'rovine', 'ruinas'],
            'ancient': ['antique', 'classical', 'antiquity', 'ancien', 'antik', 'antico', 'antiguo'],
            'roman': ['rome', 'classical', 'ancient', 'romain', 'romisch', 'romano'],
            'greek': ['greece', 'classical', 'ancient', 'hellenic', 'grec', 'griechisch', 'greco', 'griego'],
            'egyptian': ['egypt', 'ancient', 'pharaoh', 'pyramid', 'egyptien', 'agyptisch', 'egiziano', 'egipcio'],
            'bridge': ['bridges', 'crossing', 'pont', 'brucke', 'ponte', 'puente'],
            'gate': ['gateway', 'entrance', 'portal', 'porte', 'tor', 'porta', 'puerta'],
            'arch': ['arches', 'arcade', 'arc', 'bogen', 'arco'],
            'column': ['columns', 'pillar', 'classical', 'colonne', 'saule', 'colonna', 'columna'],
            'fountain': ['fountains', 'water', 'fontaine', 'brunnen', 'fontana', 'fuente'],
            'statue': ['statues', 'sculpture', 'monument', 'statue', 'statua', 'estatua'],
            'monument': ['memorial', 'statue', 'monument', 'denkmal', 'monumento'],
            'harbor': ['harbour', 'port', 'dock', 'marina', 'hafen', 'porto', 'puerto'],
            'port': ['harbor', 'harbour', 'dock', 'marina', 'hafen', 'porto', 'puerto'],
            'windmill': ['mill', 'dutch', 'moulin', 'windmuhle', 'mulino', 'molino'],
            'mill': ['windmill', 'watermill', 'moulin', 'muhle', 'mulino', 'molino'],
            'farm': ['farmhouse', 'rural', 'agricultural', 'ferme', 'bauernhof', 'fattoria', 'granja'],
            'barn': ['farm', 'rural', 'agricultural', 'grange', 'scheune', 'granaio', 'granero'],
            'cottage': ['house', 'rural', 'chaumiere', 'hutte', 'cottage', 'cabana'],
            'inn': ['tavern', 'hostel', 'auberge', 'gasthaus', 'osteria', 'posada'],
            'tavern': ['inn', 'pub', 'taverne', 'schenke', 'taverna', 'taberna'],

            // ===== INTERIOR & DOMESTIC =====
            'interior': ['interiors', 'indoor', 'room', 'interieur', 'innere', 'interno'],
            'room': ['rooms', 'interior', 'chamber', 'salle', 'zimmer', 'stanza', 'habitacion'],
            'bedroom': ['chamber', 'bed', 'sleeping', 'chambre', 'schlafzimmer', 'camera da letto'],
            'kitchen': ['cooking', 'domestic', 'cuisine', 'kuche', 'cucina', 'cocina'],
            'dining': ['dinner', 'meal', 'table', 'salle a manger', 'esszimmer'],
            'parlor': ['salon', 'sitting room', 'drawing room', 'salon', 'wohnzimmer', 'salotto'],
            'studio': ['atelier', 'workshop', 'artist', 'atelier', 'werkstatt'],
            'window': ['windows', 'light', 'fenetre', 'fenster', 'finestra', 'ventana'],
            'door': ['doorway', 'entrance', 'porte', 'tur', 'porta', 'puerta'],
            'staircase': ['stairs', 'steps', 'escalier', 'treppe', 'scala', 'escalera'],
            'fireplace': ['hearth', 'fire', 'cheminee', 'kamin', 'camino', 'chimenea'],
            'chair': ['seat', 'furniture', 'chaise', 'stuhl', 'sedia', 'silla'],
            'table': ['furniture', 'desk', 'table', 'tisch', 'tavolo', 'mesa'],
            'bed': ['bedroom', 'sleeping', 'lit', 'bett', 'letto', 'cama'],

            // ===== CLOTHING & ACCESSORIES =====
            'dress': ['gown', 'clothing', 'fashion', 'robe', 'kleid', 'vestito', 'vestido'],
            'gown': ['dress', 'clothing', 'robe', 'kleid', 'abito'],
            'hat': ['hats', 'headwear', 'chapeau', 'hut', 'cappello', 'sombrero'],
            'veil': ['veiled', 'fabric', 'voile', 'schleier', 'velo'],
            'armor': ['armour', 'knight', 'military', 'armure', 'rustung', 'armatura', 'armadura'],
            'sword': ['weapon', 'blade', 'epee', 'schwert', 'spada', 'espada'],
            'crown': ['royal', 'king', 'queen', 'couronne', 'krone', 'corona'],
            'jewelry': ['jewels', 'gems', 'bijoux', 'schmuck', 'gioielli', 'joyas'],
            'pearls': ['pearl', 'jewelry', 'necklace', 'perles', 'perlen', 'perle', 'perlas'],
            'fan': ['fans', 'accessory', 'eventail', 'facher', 'ventaglio', 'abanico'],
            'umbrella': ['parasol', 'parapluie', 'regenschirm', 'ombrello', 'paraguas'],

            // ===== ART MOVEMENTS & STYLES =====
            'impressionism': ['impressionist', 'monet', 'renoir', 'degas', 'pissarro', 'sisley'],
            'impressionist': ['impressionism', 'monet', 'renoir', 'degas', 'impressionniste'],
            'post-impressionism': ['post-impressionist', 'cezanne', 'van gogh', 'gauguin', 'seurat'],
            'baroque': ['caravaggio', 'rembrandt', 'rubens', 'vermeer', 'barock', 'barocco'],
            'renaissance': ['rinascimento', 'quattrocento', 'cinquecento', 'leonardo', 'michelangelo', 'raphael'],
            'mannerism': ['mannerist', 'pontormo', 'parmigianino', 'bronzino'],
            'rococo': ['watteau', 'boucher', 'fragonard', 'gallant', 'fete galante'],
            'neoclassicism': ['neoclassical', 'david', 'ingres', 'classical'],
            'romanticism': ['romantic', 'delacroix', 'gericault', 'turner', 'friedrich'],
            'romantic': ['romanticism', 'romantique', 'romantik', 'romantico'],
            'realism': ['realist', 'courbet', 'millet', 'realisme', 'realismus'],
            'naturalism': ['naturalist', 'nature', 'naturalisme', 'naturalismus'],
            'symbolism': ['symbolist', 'moreau', 'redon', 'symbolisme'],
            'expressionism': ['expressionist', 'munch', 'kirchner', 'nolde', 'expressionismus'],
            'cubism': ['cubist', 'picasso', 'braque', 'cubisme', 'kubismus'],
            'surrealism': ['surrealist', 'dali', 'magritte', 'ernst', 'surrealisme'],
            'abstract': ['abstraction', 'non-figurative', 'abstrakt', 'astratto', 'abstracto'],
            'classical': ['classic', 'antique', 'ancient', 'greco-roman', 'classique', 'klassisch', 'classico'],
            'gothic': ['medieval', 'gothic', 'gothique', 'gotisch', 'gotico'],
            'medieval': ['middle ages', 'gothic', 'romanesque', 'medieval', 'mittelalterlich', 'medievale'],
            'modern': ['contemporary', 'modernism', 'moderne', 'moderno'],
            'contemporary': ['modern', 'current', 'contemporain', 'zeitgenossisch', 'contemporaneo'],

            // ===== TECHNIQUES & MEDIA =====
            'painting': ['paintings', 'painted', 'peinture', 'gemalde', 'pittura', 'pintura', 'schilderij'],
            'oil painting': ['oil', 'canvas', 'huile', 'ol', 'olio', 'oleo'],
            'watercolor': ['watercolour', 'aquarelle', 'aquarell', 'acquerello', 'acuarela'],
            'drawing': ['drawings', 'sketch', 'dessin', 'zeichnung', 'disegno', 'dibujo'],
            'sketch': ['sketches', 'drawing', 'study', 'esquisse', 'skizze', 'schizzo', 'boceto'],
            'print': ['prints', 'printmaking', 'estampe', 'druck', 'stampa', 'grabado'],
            'etching': ['etchings', 'print', 'engraving', 'gravure', 'radierung', 'acquaforte', 'aguafuerte'],
            'engraving': ['engravings', 'print', 'gravure', 'stich', 'incisione', 'grabado'],
            'lithograph': ['lithography', 'print', 'lithographie', 'lithografie', 'litografia'],
            'woodcut': ['woodcuts', 'print', 'woodblock', 'gravure sur bois', 'holzschnitt', 'xilografia'],
            'fresco': ['frescos', 'mural', 'wall painting', 'freske', 'affresco'],
            'tempera': ['egg tempera', 'panel', 'tempera'],
            'pastel': ['pastels', 'chalk', 'pastel'],
            'charcoal': ['drawing', 'fusain', 'kohle', 'carboncino', 'carbon'],
            'sculpture': ['sculptures', 'sculpted', 'statue', 'skulptur', 'scultura', 'escultura'],
            'bronze': ['bronzes', 'sculpture', 'metal', 'bronze', 'bronzo', 'bronce'],
            'marble': ['sculpture', 'stone', 'marbre', 'marmor', 'marmo', 'marmol'],
            'terracotta': ['clay', 'ceramic', 'terre cuite', 'terrakotta'],
            'ceramic': ['ceramics', 'pottery', 'porcelain', 'ceramique', 'keramik', 'ceramica'],
            'porcelain': ['ceramic', 'china', 'porcelaine', 'porzellan', 'porcellana', 'porcelana'],
            'tapestry': ['tapestries', 'textile', 'weaving', 'tapisserie', 'wandteppich', 'arazzo', 'tapiz'],
            'mosaic': ['mosaics', 'tile', 'mosaique', 'mosaik', 'mosaico'],
            'miniature': ['miniatures', 'illumination', 'miniatura'],
            'illumination': ['illuminated', 'manuscript', 'medieval', 'enluminure', 'illumination'],
            'icon': ['icons', 'religious', 'byzantine', 'icone', 'ikone', 'icona', 'icono'],
            'altarpiece': ['altar', 'religious', 'retable', 'altarbild', 'pala d\'altare', 'retablo'],
            'triptych': ['altarpiece', 'three panels', 'triptyque', 'triptychon', 'trittico', 'triptico'],
            'diptych': ['two panels', 'diptyque', 'diptychon', 'dittico', 'diptico'],

            // ===== COLORS =====
            'red': ['crimson', 'scarlet', 'vermilion', 'rouge', 'rot', 'rosso', 'rojo'],
            'blue': ['azure', 'cobalt', 'ultramarine', 'bleu', 'blau', 'blu', 'azul'],
            'green': ['emerald', 'verdant', 'vert', 'grun', 'verde'],
            'yellow': ['golden', 'amber', 'jaune', 'gelb', 'giallo', 'amarillo'],
            'gold': ['golden', 'gilded', 'or', 'gold', 'oro'],
            'white': ['ivory', 'pale', 'blanc', 'weiss', 'bianco', 'blanco'],
            'black': ['dark', 'ebony', 'noir', 'schwarz', 'nero', 'negro'],
            'brown': ['umber', 'sienna', 'brun', 'braun', 'marrone', 'marron'],
            'purple': ['violet', 'mauve', 'pourpre', 'violett', 'viola', 'purpura'],
            'pink': ['rose', 'blush', 'rose', 'rosa'],
            'orange': ['tangerine', 'orange', 'arancione', 'naranja'],
            'gray': ['grey', 'silver', 'gris', 'grau', 'grigio'],

            // ===== LIGHT & ATMOSPHERE =====
            'light': ['lighting', 'illumination', 'lumiere', 'licht', 'luce', 'luz'],
            'shadow': ['shadows', 'shade', 'dark', 'ombre', 'schatten', 'ombra', 'sombra'],
            'chiaroscuro': ['light', 'shadow', 'contrast', 'clair-obscur'],
            'sfumato': ['hazy', 'smoky', 'atmospheric'],
            'tenebrism': ['dark', 'dramatic', 'caravaggio'],
            'atmospheric': ['atmosphere', 'hazy', 'misty', 'mood'],

            // ===== COMPOSITION =====
            'reclining': ['recumbent', 'lying', 'horizontal', 'couche', 'liegend', 'disteso'],
            'standing': ['upright', 'vertical', 'debout', 'stehend', 'in piedi'],
            'seated': ['sitting', 'enthroned', 'assis', 'sitzend', 'seduto', 'sentado'],
            'kneeling': ['genuflecting', 'agenouille', 'kniend', 'inginocchiato'],
            'profile': ['side view', 'profil', 'profilo', 'perfil'],
            'frontal': ['front view', 'facing', 'frontal', 'frontale'],
            'three-quarter': ['three quarter view', 'trois-quarts'],

            // ===== EMOTIONS & EXPRESSIONS =====
            'joy': ['joyful', 'happy', 'happiness', 'joie', 'freude', 'gioia', 'alegria'],
            'sorrow': ['sad', 'sadness', 'grief', 'melancholy', 'tristesse', 'trauer', 'tristezza'],
            'melancholy': ['melancholic', 'pensive', 'wistful', 'melancolie', 'melancholie', 'malinconia'],
            'peace': ['peaceful', 'serene', 'tranquil', 'paix', 'frieden', 'pace', 'paz'],
            'passion': ['passionate', 'intense', 'emotion', 'passion', 'leidenschaft', 'passione', 'pasion'],
            'ecstasy': ['ecstatic', 'rapture', 'divine', 'extase', 'ekstase', 'estasi', 'extasis'],
            'contemplation': ['contemplative', 'meditation', 'thought', 'contemplation', 'betrachtung'],
            'innocence': ['innocent', 'purity', 'childhood', 'innocence', 'unschuld', 'innocenza'],

            // ===== CONCEPTS & ALLEGORY =====
            'allegory': ['allegorical', 'symbolic', 'allegorie', 'allegoria'],
            'vanity': ['vanitas', 'pride', 'mortality', 'vanite', 'eitelkeit', 'vanita'],
            'virtue': ['virtues', 'moral', 'vertu', 'tugend', 'virtu', 'virtud'],
            'vice': ['vices', 'sin', 'moral', 'vice', 'laster', 'vizio', 'vicio'],
            'fortune': ['fate', 'destiny', 'chance', 'fortuna', 'schicksal'],
            'time': ['temporal', 'chronos', 'temps', 'zeit', 'tempo', 'tiempo'],
            'truth': ['verity', 'verite', 'wahrheit', 'verita', 'verdad'],
            'justice': ['justitia', 'law', 'justice', 'gerechtigkeit', 'giustizia', 'justicia'],
            'wisdom': ['sophia', 'knowledge', 'sagesse', 'weisheit', 'saggezza', 'sabiduria'],
            'abundance': ['plenty', 'prosperity', 'abondance', 'fulle', 'abbondanza', 'abundancia'],
            'fertility': ['fecundity', 'fruitful', 'fertilite', 'fruchtbarkeit', 'fertilita'],
            'triumph': ['triumphant', 'victory', 'triomphe', 'triumph', 'trionfo', 'triunfo'],

            // ===== GEOGRAPHIC & CULTURAL =====
            'italian': ['italy', 'italian', 'italien', 'italiano'],
            'french': ['france', 'francais', 'franzosisch', 'francese', 'frances'],
            'dutch': ['holland', 'netherlands', 'flemish', 'hollandais', 'niederlandisch', 'olandese'],
            'flemish': ['dutch', 'flanders', 'belgian', 'flamand', 'flamisch', 'fiammingo'],
            'spanish': ['spain', 'espagnol', 'spanisch', 'spagnolo', 'espanol'],
            'german': ['germany', 'allemand', 'deutsch', 'tedesco', 'aleman'],
            'english': ['britain', 'british', 'anglais', 'englisch', 'inglese', 'ingles'],
            'american': ['america', 'united states', 'americain', 'amerikanisch', 'americano'],
            'japanese': ['japan', 'japonais', 'japanisch', 'giapponese', 'japones', 'ukiyo-e'],
            'chinese': ['china', 'chinois', 'chinesisch', 'cinese', 'chino'],
            'indian': ['india', 'indien', 'indisch', 'indiano', 'indio'],
            'persian': ['persia', 'iran', 'persian', 'persisch', 'persiano', 'persa'],
            'oriental': ['eastern', 'asian', 'exotic', 'orientalisch', 'orientale'],
            'venetian': ['venice', 'venitien', 'venezianisch', 'veneziano', 'veneciano'],
            'florentine': ['florence', 'florentin', 'florentinisch', 'fiorentino', 'florentino'],
            'parisian': ['paris', 'parisien', 'pariser', 'parigino', 'parisino'],

            // ===== COMMON OBJECTS =====
            'book': ['books', 'tome', 'volume', 'reading', 'literature', 'livre', 'buch', 'libro'],
            'books': ['book', 'library', 'reading', 'literature', 'livres', 'bucher', 'libri', 'libros'],
            'plate': ['plates', 'dish', 'platter', 'ceramic', 'assiette', 'teller', 'piatto', 'plato'],
            'dish': ['dishes', 'plate', 'bowl', 'platter', 'plat', 'schale', 'piatto'],
            'coin': ['coins', 'money', 'currency', 'medal', 'piece', 'munze', 'moneta', 'moneda'],
            'coins': ['coin', 'money', 'currency', 'medals', 'pieces', 'munzen', 'monete'],
            'medal': ['medals', 'coin', 'medallion', 'award', 'medaille', 'medaille', 'medaglia', 'medalla'],
            'key': ['keys', 'lock', 'cle', 'schlussel', 'chiave', 'llave'],
            'lock': ['locks', 'key', 'padlock', 'serrure', 'schloss', 'serratura', 'cerradura'],
            'ring': ['rings', 'jewelry', 'band', 'anneau', 'ring', 'anello', 'anillo'],
            'necklace': ['necklaces', 'jewelry', 'pearls', 'chain', 'collier', 'halskette', 'collana', 'collar'],
            'bracelet': ['bracelets', 'jewelry', 'bangle', 'bracelet', 'armband', 'braccialetto', 'pulsera'],
            'earring': ['earrings', 'jewelry', 'boucle d\'oreille', 'ohrring', 'orecchino', 'pendiente'],
            'watch': ['watches', 'timepiece', 'clock', 'montre', 'uhr', 'orologio', 'reloj'],
            'clock': ['clocks', 'time', 'timepiece', 'watch', 'horloge', 'uhr', 'orologio', 'reloj'],
            'lamp': ['lamps', 'lantern', 'light', 'lampe', 'lampe', 'lampada', 'lampara'],
            'lantern': ['lanterns', 'lamp', 'light', 'lanterne', 'laterne', 'lanterna', 'linterna'],
            'candle': ['candles', 'candlestick', 'flame', 'light', 'bougie', 'kerze', 'candela', 'vela'],
            'candlestick': ['candleholder', 'candle', 'chandelier', 'bougeoir', 'kerzenhalter', 'candeliere'],
            'torch': ['torches', 'flame', 'light', 'flambeau', 'fackel', 'torcia', 'antorcha'],
            'bottle': ['bottles', 'flask', 'vessel', 'wine', 'bouteille', 'flasche', 'bottiglia', 'botella'],
            'flask': ['flasks', 'bottle', 'vessel', 'flacon', 'flasche', 'fiasco', 'frasco'],
            'jug': ['jugs', 'pitcher', 'vessel', 'cruche', 'krug', 'brocca', 'jarra'],
            'pitcher': ['pitchers', 'jug', 'ewer', 'vessel', 'cruche', 'krug', 'brocca'],
            'ewer': ['ewers', 'pitcher', 'vessel', 'aiguiere', 'kanne', 'brocca', 'aguamanil'],
            'cup': ['cups', 'goblet', 'chalice', 'tasse', 'tasse', 'tazza', 'taza'],
            'goblet': ['goblets', 'cup', 'chalice', 'wine', 'coupe', 'pokal', 'calice', 'copa'],
            'chalice': ['chalices', 'goblet', 'cup', 'sacred', 'calice', 'kelch', 'calice', 'caliz'],
            'bowl': ['bowls', 'dish', 'vessel', 'bol', 'schale', 'ciotola', 'cuenco'],
            'basket': ['baskets', 'wicker', 'container', 'panier', 'korb', 'cesto', 'cesta'],
            'box': ['boxes', 'chest', 'container', 'casket', 'boite', 'kasten', 'scatola', 'caja'],
            'chest': ['chests', 'box', 'trunk', 'coffer', 'coffre', 'truhe', 'cassone', 'cofre'],
            'trunk': ['trunks', 'chest', 'luggage', 'malle', 'koffer', 'baule', 'baul'],
            'casket': ['caskets', 'box', 'jewel box', 'coffret', 'kastchen', 'cofanetto'],
            'jar': ['jars', 'pot', 'vessel', 'container', 'pot', 'topf', 'vaso', 'tarro'],
            'pot': ['pots', 'jar', 'vessel', 'container', 'pot', 'topf', 'pentola', 'olla'],
            'urn': ['urns', 'vase', 'vessel', 'classical', 'urne', 'urne', 'urna'],
            'vase': ['vases', 'vessel', 'flowers', 'urn', 'vase', 'vase', 'vaso', 'florero'],
            'amphora': ['amphorae', 'vase', 'greek', 'vessel', 'amphore', 'amphore', 'anfora'],
            'globe': ['globes', 'sphere', 'world', 'earth', 'globe', 'globus', 'globo'],
            'map': ['maps', 'chart', 'cartography', 'carte', 'karte', 'mappa', 'mapa'],
            'compass': ['compasses', 'navigation', 'instrument', 'boussole', 'kompass', 'bussola', 'brujula'],
            'telescope': ['telescopes', 'instrument', 'astronomy', 'telescope', 'teleskop', 'telescopio'],
            'microscope': ['microscopes', 'instrument', 'science', 'microscope', 'mikroskop', 'microscopio'],
            'hourglass': ['hourglasses', 'time', 'sand', 'sablier', 'sanduhr', 'clessidra', 'reloj de arena'],
            'scale': ['scales', 'balance', 'weighing', 'justice', 'balance', 'waage', 'bilancia', 'balanza'],
            'balance': ['balances', 'scale', 'weighing', 'justice', 'balance', 'waage', 'bilancia'],
            'bell': ['bells', 'chime', 'cloche', 'glocke', 'campana'],
            'drum': ['drums', 'percussion', 'music', 'tambour', 'trommel', 'tamburo', 'tambor'],
            'horn': ['horns', 'trumpet', 'music', 'hunting', 'cor', 'horn', 'corno', 'cuerno'],
            'trumpet': ['trumpets', 'horn', 'music', 'brass', 'trompette', 'trompete', 'tromba', 'trompeta'],
            'harp': ['harps', 'music', 'strings', 'harpe', 'harfe', 'arpa'],
            'lyre': ['lyres', 'music', 'strings', 'classical', 'lyre', 'leier', 'lira'],
            'guitar': ['guitars', 'music', 'strings', 'guitare', 'gitarre', 'chitarra', 'guitarra'],
            'organ': ['organs', 'music', 'church', 'orgue', 'orgel', 'organo'],
            'piano': ['pianos', 'music', 'keyboard', 'piano', 'klavier', 'pianoforte'],
            'pen': ['pens', 'quill', 'writing', 'plume', 'feder', 'penna', 'pluma'],
            'quill': ['quills', 'pen', 'feather', 'writing', 'plume', 'federkiel', 'penna'],
            'inkwell': ['ink', 'writing', 'desk', 'encrier', 'tintenfass', 'calamaio', 'tintero'],
            'scroll': ['scrolls', 'manuscript', 'paper', 'rouleau', 'schriftrolle', 'rotolo', 'rollo'],
            'manuscript': ['manuscripts', 'book', 'document', 'illuminated', 'manuscrit', 'manuskript', 'manoscritto'],
            'letter': ['letters', 'correspondence', 'epistle', 'mail', 'lettre', 'brief', 'lettera', 'carta'],
            'envelope': ['envelopes', 'letter', 'mail', 'enveloppe', 'umschlag', 'busta', 'sobre'],
            'seal': ['seals', 'stamp', 'wax', 'sceau', 'siegel', 'sigillo', 'sello'],
            'stamp': ['stamps', 'seal', 'postal', 'timbre', 'stempel', 'francobollo', 'sello'],
            'newspaper': ['newspapers', 'journal', 'press', 'journal', 'zeitung', 'giornale', 'periodico'],
            'paper': ['papers', 'document', 'sheet', 'papier', 'papier', 'carta', 'papel'],
            'ribbon': ['ribbons', 'bow', 'fabric', 'ruban', 'band', 'nastro', 'cinta'],
            'rope': ['ropes', 'cord', 'string', 'corde', 'seil', 'corda', 'cuerda'],
            'chain': ['chains', 'links', 'metal', 'chaine', 'kette', 'catena', 'cadena'],
            'needle': ['needles', 'sewing', 'thread', 'aiguille', 'nadel', 'ago', 'aguja'],
            'thread': ['threads', 'sewing', 'yarn', 'fil', 'faden', 'filo', 'hilo'],
            'scissors': ['shears', 'cutting', 'ciseaux', 'schere', 'forbici', 'tijeras'],
            'knife': ['knives', 'blade', 'cutting', 'couteau', 'messer', 'coltello', 'cuchillo'],
            'dagger': ['daggers', 'blade', 'weapon', 'poignard', 'dolch', 'pugnale', 'daga'],
            'sword': ['swords', 'blade', 'weapon', 'epee', 'schwert', 'spada', 'espada'],
            'spear': ['spears', 'lance', 'weapon', 'lance', 'speer', 'lancia', 'lanza'],
            'lance': ['lances', 'spear', 'weapon', 'knight', 'lance', 'lanze', 'lancia'],
            'shield': ['shields', 'armor', 'defense', 'bouclier', 'schild', 'scudo', 'escudo'],
            'helmet': ['helmets', 'armor', 'head', 'casque', 'helm', 'elmo', 'casco'],
            'bow': ['bows', 'arrow', 'archery', 'weapon', 'arc', 'bogen', 'arco'],
            'arrow': ['arrows', 'bow', 'archery', 'cupid', 'fleche', 'pfeil', 'freccia', 'flecha'],
            'quiver': ['quivers', 'arrows', 'archery', 'carquois', 'kocher', 'faretra', 'carcaj'],
            'gun': ['guns', 'firearm', 'pistol', 'rifle', 'fusil', 'gewehr', 'fucile', 'arma'],
            'pistol': ['pistols', 'gun', 'firearm', 'pistolet', 'pistole', 'pistola'],
            'cannon': ['cannons', 'artillery', 'weapon', 'canon', 'kanone', 'cannone', 'canon'],
            'flag': ['flags', 'banner', 'standard', 'drapeau', 'flagge', 'bandiera', 'bandera'],
            'banner': ['banners', 'flag', 'standard', 'pennant', 'banniere', 'banner', 'stendardo', 'estandarte'],
            'cross': ['crosses', 'crucifix', 'religious', 'croix', 'kreuz', 'croce', 'cruz'],
            'crucifix': ['crucifixes', 'cross', 'christ', 'religious', 'crucifix', 'kruzifix', 'crocifisso'],
            'rosary': ['rosaries', 'beads', 'prayer', 'religious', 'chapelet', 'rosenkranz', 'rosario'],
            'censer': ['censers', 'incense', 'religious', 'encensoir', 'weihrauchfass', 'turibolo', 'incensario'],
            'incense': ['censer', 'smoke', 'religious', 'encens', 'weihrauch', 'incenso'],
            'altar': ['altars', 'church', 'religious', 'sacrifice', 'autel', 'altar', 'altare'],
            'throne': ['thrones', 'seat', 'royal', 'king', 'trone', 'thron', 'trono'],
            'scepter': ['sceptre', 'royal', 'king', 'power', 'sceptre', 'zepter', 'scettro', 'cetro'],
            'orb': ['orbs', 'sphere', 'royal', 'globe', 'orbe', 'reichsapfel', 'globo'],
            'crown': ['crowns', 'royal', 'king', 'queen', 'couronne', 'krone', 'corona'],
            'tiara': ['tiaras', 'crown', 'papal', 'headdress', 'tiare', 'tiara'],
            'wreath': ['wreaths', 'garland', 'laurel', 'flowers', 'couronne', 'kranz', 'ghirlanda', 'corona'],
            'garland': ['garlands', 'wreath', 'flowers', 'festoon', 'guirlande', 'girlande', 'ghirlanda', 'guirnalda'],
            'mask': ['masks', 'face', 'theater', 'carnival', 'masque', 'maske', 'maschera', 'mascara'],
            'puppet': ['puppets', 'marionette', 'doll', 'theater', 'marionnette', 'puppe', 'burattino', 'titere'],
            'doll': ['dolls', 'toy', 'puppet', 'poupee', 'puppe', 'bambola', 'muneca'],
            'toy': ['toys', 'plaything', 'game', 'jouet', 'spielzeug', 'giocattolo', 'juguete'],
            'ball': ['balls', 'sphere', 'game', 'balle', 'ball', 'palla', 'pelota'],
            'dice': ['die', 'game', 'gambling', 'de', 'wurfel', 'dado'],
            'cards': ['card', 'playing', 'game', 'gambling', 'cartes', 'karten', 'carte', 'naipes'],
            'chess': ['chessboard', 'game', 'strategy', 'echecs', 'schach', 'scacchi', 'ajedrez'],
            'wheel': ['wheels', 'cart', 'fortune', 'roue', 'rad', 'ruota', 'rueda'],
            'cart': ['carts', 'wagon', 'wheel', 'vehicle', 'chariot', 'wagen', 'carro', 'carreta'],
            'wagon': ['wagons', 'cart', 'vehicle', 'chariot', 'wagen', 'carro'],
            'carriage': ['carriages', 'coach', 'vehicle', 'voiture', 'kutsche', 'carrozza', 'carruaje'],
            'coach': ['coaches', 'carriage', 'vehicle', 'coche', 'kutsche', 'cocchio'],
            'saddle': ['saddles', 'horse', 'riding', 'selle', 'sattel', 'sella', 'silla'],
            'bridle': ['bridles', 'horse', 'reins', 'bride', 'zaum', 'briglia', 'brida'],
            'whip': ['whips', 'riding', 'fouet', 'peitsche', 'frusta', 'latigo'],
            'anchor': ['anchors', 'ship', 'maritime', 'ancre', 'anker', 'ancora', 'ancla'],
            'oar': ['oars', 'boat', 'rowing', 'rame', 'ruder', 'remo'],
            'sail': ['sails', 'ship', 'boat', 'voile', 'segel', 'vela'],
            'net': ['nets', 'fishing', 'filet', 'netz', 'rete', 'red'],
            'fishing rod': ['rod', 'fishing', 'angling', 'canne a peche', 'angelrute', 'canna da pesca'],
            'hook': ['hooks', 'fishing', 'crochet', 'haken', 'gancio', 'gancho'],
            'hammer': ['hammers', 'tool', 'marteau', 'hammer', 'martello', 'martillo'],
            'anvil': ['anvils', 'forge', 'blacksmith', 'enclume', 'amboss', 'incudine', 'yunque'],
            'axe': ['axes', 'tool', 'hache', 'axt', 'ascia', 'hacha'],
            'saw': ['saws', 'tool', 'woodwork', 'scie', 'sage', 'sega', 'sierra'],
            'chisel': ['chisels', 'tool', 'sculpture', 'ciseau', 'meissel', 'scalpello', 'cincel'],
            'brush': ['brushes', 'painting', 'artist', 'pinceau', 'pinsel', 'pennello', 'pincel'],
            'palette': ['palettes', 'painting', 'artist', 'colors', 'palette', 'palette', 'tavolozza', 'paleta'],
            'easel': ['easels', 'painting', 'artist', 'chevalet', 'staffelei', 'cavalletto', 'caballete'],
            'canvas': ['canvases', 'painting', 'toile', 'leinwand', 'tela', 'lienzo'],
            'frame': ['frames', 'picture', 'painting', 'cadre', 'rahmen', 'cornice', 'marco'],
            'plow': ['plough', 'plows', 'farming', 'agriculture', 'charrue', 'pflug', 'aratro', 'arado'],
            'scythe': ['scythes', 'harvest', 'farming', 'death', 'faux', 'sense', 'falce', 'guadana'],
            'sickle': ['sickles', 'harvest', 'farming', 'faucille', 'sichel', 'falcetto', 'hoz'],
            'rake': ['rakes', 'garden', 'farming', 'rateau', 'rechen', 'rastrello', 'rastrillo'],
            'shovel': ['shovels', 'spade', 'digging', 'pelle', 'schaufel', 'pala'],
            'spade': ['spades', 'shovel', 'digging', 'garden', 'beche', 'spaten', 'vanga', 'pala'],
            'hoe': ['hoes', 'garden', 'farming', 'houe', 'hacke', 'zappa', 'azada'],
            'bucket': ['buckets', 'pail', 'water', 'seau', 'eimer', 'secchio', 'cubo'],
            'pail': ['pails', 'bucket', 'water', 'seau', 'eimer', 'secchio'],
            'barrel': ['barrels', 'cask', 'wine', 'tonneau', 'fass', 'botte', 'barril'],
            'cask': ['casks', 'barrel', 'wine', 'tonneau', 'fass', 'botte'],
            'broom': ['brooms', 'sweeping', 'cleaning', 'balai', 'besen', 'scopa', 'escoba'],
            'mop': ['mops', 'cleaning', 'floor', 'balai', 'mopp', 'mocio', 'fregona'],
            'soap': ['soaps', 'washing', 'cleaning', 'savon', 'seife', 'sapone', 'jabon'],
            'towel': ['towels', 'cloth', 'drying', 'serviette', 'handtuch', 'asciugamano', 'toalla'],
            'napkin': ['napkins', 'cloth', 'table', 'serviette', 'serviette', 'tovagliolo', 'servilleta'],
            'tablecloth': ['cloth', 'table', 'linen', 'nappe', 'tischtuch', 'tovaglia', 'mantel'],
            'pillow': ['pillows', 'cushion', 'bed', 'oreiller', 'kissen', 'cuscino', 'almohada'],
            'cushion': ['cushions', 'pillow', 'seat', 'coussin', 'kissen', 'cuscino', 'cojin'],
            'blanket': ['blankets', 'cover', 'bed', 'couverture', 'decke', 'coperta', 'manta'],
            'sheet': ['sheets', 'bed', 'linen', 'drap', 'laken', 'lenzuolo', 'sabana'],
            'quilt': ['quilts', 'blanket', 'bed', 'coverlet', 'courtepointe', 'steppdecke', 'trapunta', 'colcha'],
            'rug': ['rugs', 'carpet', 'floor', 'tapis', 'teppich', 'tappeto', 'alfombra'],
            'carpet': ['carpets', 'rug', 'floor', 'oriental', 'tapis', 'teppich', 'tappeto', 'alfombra'],
            'tapestry': ['tapestries', 'weaving', 'wall', 'textile', 'tapisserie', 'wandteppich', 'arazzo', 'tapiz'],
            'curtain': ['curtains', 'drape', 'window', 'rideau', 'vorhang', 'tenda', 'cortina'],
            'drape': ['drapes', 'curtain', 'fabric', 'draperie', 'vorhang', 'drappo'],
            'cloth': ['fabric', 'textile', 'material', 'tissu', 'stoff', 'stoffa', 'tela'],
            'fabric': ['cloth', 'textile', 'material', 'tissu', 'stoff', 'tessuto', 'tejido'],
            'silk': ['silks', 'fabric', 'textile', 'soie', 'seide', 'seta', 'seda'],
            'velvet': ['velvets', 'fabric', 'textile', 'velours', 'samt', 'velluto', 'terciopelo'],
            'lace': ['laces', 'fabric', 'textile', 'delicate', 'dentelle', 'spitze', 'pizzo', 'encaje'],
            'embroidery': ['embroidered', 'needlework', 'textile', 'broderie', 'stickerei', 'ricamo', 'bordado'],
            'satin': ['fabric', 'textile', 'shiny', 'satin', 'raso'],
            'linen': ['fabric', 'textile', 'cloth', 'lin', 'leinen', 'lino'],
            'wool': ['woolen', 'fabric', 'textile', 'sheep', 'laine', 'wolle', 'lana'],
            'cotton': ['fabric', 'textile', 'coton', 'baumwolle', 'cotone', 'algodon'],
            'leather': ['hide', 'skin', 'material', 'cuir', 'leder', 'cuoio', 'cuero'],
            'fur': ['furs', 'pelt', 'animal', 'fourrure', 'pelz', 'pelliccia', 'piel'],
            'feather': ['feathers', 'plume', 'bird', 'plume', 'feder', 'piuma', 'pluma'],
            'shell': ['shells', 'seashell', 'conch', 'coquille', 'muschel', 'conchiglia', 'concha'],
            'coral': ['corals', 'marine', 'red', 'corail', 'koralle', 'corallo'],
            'pearl': ['pearls', 'jewelry', 'oyster', 'perle', 'perle', 'perla'],
            'diamond': ['diamonds', 'gem', 'jewel', 'diamant', 'diamant', 'diamante'],
            'ruby': ['rubies', 'gem', 'jewel', 'red', 'rubis', 'rubin', 'rubino', 'rubi'],
            'emerald': ['emeralds', 'gem', 'jewel', 'green', 'emeraude', 'smaragd', 'smeraldo', 'esmeralda'],
            'sapphire': ['sapphires', 'gem', 'jewel', 'blue', 'saphir', 'saphir', 'zaffiro', 'zafiro'],
            'crystal': ['crystals', 'glass', 'clear', 'cristal', 'kristall', 'cristallo'],
            'glass': ['glasses', 'crystal', 'vessel', 'verre', 'glas', 'vetro', 'vidrio'],
            'porcelain': ['china', 'ceramic', 'pottery', 'porcelaine', 'porzellan', 'porcellana', 'porcelana'],
            'pottery': ['ceramic', 'clay', 'earthenware', 'poterie', 'topferei', 'ceramica', 'alfareria'],
            'ceramic': ['ceramics', 'pottery', 'clay', 'ceramique', 'keramik', 'ceramica'],
            'clay': ['earthenware', 'pottery', 'terracotta', 'argile', 'ton', 'argilla', 'arcilla'],
            'brick': ['bricks', 'building', 'masonry', 'brique', 'ziegel', 'mattone', 'ladrillo'],
            'stone': ['stones', 'rock', 'masonry', 'pierre', 'stein', 'pietra', 'piedra'],
            'marble': ['marbles', 'stone', 'sculpture', 'classical', 'marbre', 'marmor', 'marmo', 'marmol'],
            'granite': ['stone', 'rock', 'granit', 'granit', 'granito'],
            'jade': ['jades', 'stone', 'green', 'chinese', 'jade', 'giada'],
            'ivory': ['ivories', 'tusk', 'elephant', 'white', 'ivoire', 'elfenbein', 'avorio', 'marfil'],
            'bone': ['bones', 'skeleton', 'os', 'knochen', 'osso', 'hueso'],
            'wood': ['wooden', 'timber', 'bois', 'holz', 'legno', 'madera'],
            'metal': ['metals', 'metallic', 'metal', 'metall', 'metallo'],
            'gold': ['golden', 'gilded', 'precious', 'or', 'gold', 'oro'],
            'silver': ['silvery', 'precious', 'argent', 'silber', 'argento', 'plata'],
            'bronze': ['bronzes', 'metal', 'sculpture', 'bronze', 'bronze', 'bronzo', 'bronce'],
            'copper': ['metal', 'cuivre', 'kupfer', 'rame', 'cobre'],
            'iron': ['metal', 'fer', 'eisen', 'ferro', 'hierro'],
            'steel': ['metal', 'blade', 'acier', 'stahl', 'acciaio', 'acero'],
            'tin': ['metal', 'etain', 'zinn', 'stagno', 'estano'],
            'lead': ['metal', 'plomb', 'blei', 'piombo', 'plomo'],
            'brass': ['metal', 'laiton', 'messing', 'ottone', 'laton'],
            'pewter': ['metal', 'etain', 'zinn', 'peltro', 'peltre'],
            'wax': ['candle', 'seal', 'cire', 'wachs', 'cera'],
            'soap': ['washing', 'cleaning', 'savon', 'seife', 'sapone', 'jabon'],
            'perfume': ['fragrance', 'scent', 'bottle', 'parfum', 'parfum', 'profumo', 'perfume'],
            'tobacco': ['smoking', 'pipe', 'tabac', 'tabak', 'tabacco', 'tabaco'],
            'wine': ['grapes', 'bottle', 'glass', 'drinking', 'vin', 'wein', 'vino'],
            'beer': ['ale', 'drinking', 'tavern', 'biere', 'bier', 'birra', 'cerveza'],
            'coffee': ['cup', 'drinking', 'cafe', 'kaffee', 'caffe', 'cafe'],
            'tea': ['cup', 'drinking', 'the', 'tee', 'te'],
            'milk': ['dairy', 'pitcher', 'lait', 'milch', 'latte', 'leche'],
            'egg': ['eggs', 'food', 'oeuf', 'ei', 'uovo', 'huevo'],
            'butter': ['dairy', 'food', 'beurre', 'butter', 'burro', 'mantequilla'],
            'salt': ['spice', 'seasoning', 'sel', 'salz', 'sale', 'sal'],
            'pepper': ['spice', 'seasoning', 'poivre', 'pfeffer', 'pepe', 'pimienta'],
            'sugar': ['sweet', 'sucre', 'zucker', 'zucchero', 'azucar'],
            'honey': ['sweet', 'bee', 'miel', 'honig', 'miele', 'miel'],
            'cake': ['pastry', 'dessert', 'sweet', 'gateau', 'kuchen', 'torta', 'pastel'],
            'pie': ['pastry', 'dessert', 'tarte', 'kuchen', 'torta', 'pastel'],
            'ice cream': ['dessert', 'sweet', 'frozen', 'glace', 'eis', 'gelato', 'helado']
        };

        // Expand a search query with synonyms and related terms
        function expandSearchQuery(query) {
            if (!query) return query;

            const lowerQuery = query.toLowerCase().trim();

            // Check if the query matches any synonym key
            if (SEARCH_SYNONYMS[lowerQuery]) {
                // Return original term plus a selection of synonyms (not all, to avoid overwhelming)
                const synonyms = SEARCH_SYNONYMS[lowerQuery];
                const selectedSynonyms = synonyms.slice(0, 5); // Take first 5 synonyms
                return [query, ...selectedSynonyms].join(' OR ');
            }

            // Check if query contains a word that has synonyms
            const words = lowerQuery.split(/\s+/);
            let expanded = false;
            let expandedTerms = [query];

            for (const word of words) {
                if (SEARCH_SYNONYMS[word]) {
                    const synonyms = SEARCH_SYNONYMS[word].slice(0, 3); // Take first 3 for multi-word queries
                    expandedTerms.push(...synonyms);
                    expanded = true;
                }
            }

            if (expanded) {
                return expandedTerms.join(' OR ');
            }

            return query;
        }

        // Get singular/plural variant of a word
        function getSingularPluralVariant(word) {
            const lower = word.toLowerCase();
            // Common irregular plurals
            const irregulars = {
                'children': 'child', 'child': 'children',
                'men': 'man', 'man': 'men',
                'women': 'woman', 'woman': 'women',
                'people': 'person', 'person': 'people',
                'leaves': 'leaf', 'leaf': 'leaves',
                'wolves': 'wolf', 'wolf': 'wolves',
                'lives': 'life', 'life': 'lives',
                'knives': 'knife', 'knife': 'knives',
                'wives': 'wife', 'wife': 'wives',
                'selves': 'self', 'self': 'selves',
                'feet': 'foot', 'foot': 'feet',
                'teeth': 'tooth', 'tooth': 'teeth',
                'geese': 'goose', 'goose': 'geese',
                'mice': 'mouse', 'mouse': 'mice',
                'oxen': 'ox', 'ox': 'oxen',
                'sheep': 'sheep', 'fish': 'fish', 'deer': 'deer'
            };
            if (irregulars[lower]) return irregulars[lower];

            // Handle common plural patterns
            if (lower.endsWith('ies')) {
                return lower.slice(0, -3) + 'y'; // butterflies -> butterfly
            } else if (lower.endsWith('ves')) {
                return lower.slice(0, -3) + 'f'; // calves -> calf
            } else if (lower.endsWith('es') && (lower.endsWith('shes') || lower.endsWith('ches') || lower.endsWith('xes') || lower.endsWith('sses') || lower.endsWith('zes'))) {
                return lower.slice(0, -2); // bushes -> bush, watches -> watch
            } else if (lower.endsWith('s') && !lower.endsWith('ss')) {
                return lower.slice(0, -1); // cats -> cat
            }

            // If singular, try adding plural forms
            if (lower.endsWith('y') && !['ay', 'ey', 'oy', 'uy'].some(v => lower.endsWith(v))) {
                return lower.slice(0, -1) + 'ies'; // butterfly -> butterflies
            } else if (lower.endsWith('f')) {
                return lower.slice(0, -1) + 'ves'; // calf -> calves
            } else if (lower.endsWith('fe')) {
                return lower.slice(0, -2) + 'ves'; // knife -> knives
            } else if (['sh', 'ch', 'x', 's', 'z'].some(end => lower.endsWith(end))) {
                return lower + 'es'; // bush -> bushes
            } else {
                return lower + 's'; // cat -> cats
            }
        }

        // Get expanded terms as an array (for APIs that don't support OR syntax)
        function getExpandedTermsArray(query) {
            if (!query) return [query];

            const lowerQuery = query.toLowerCase().trim();
            const variant = getSingularPluralVariant(lowerQuery);

            // Collect terms from both the original query and its singular/plural variant
            let terms = new Set([query]);

            // Add variant (singular or plural form)
            if (variant && variant !== lowerQuery) {
                terms.add(variant);
            }

            // Check synonyms for both the query and its variant
            if (SEARCH_SYNONYMS[lowerQuery]) {
                SEARCH_SYNONYMS[lowerQuery].slice(0, 4).forEach(s => terms.add(s));
            }
            if (variant && SEARCH_SYNONYMS[variant]) {
                SEARCH_SYNONYMS[variant].slice(0, 4).forEach(s => terms.add(s));
            }

            return Array.from(terms).slice(0, 6);
        }

        // Track recently used terms to maximize variety
        let usedSearchTerms = new Set();
        let usedWikiTerms = new Set();
        const MAX_USED_TERMS = 20; // Reset after using this many unique terms

        function getRandomSearchTerm(usedSet, termsArray) {
            // Get unused terms
            const unusedTerms = termsArray.filter(t => !usedSet.has(t));

            // If all terms used, reset and use any
            if (unusedTerms.length === 0) {
                usedSet.clear();
                const term = termsArray[Math.floor(Math.random() * termsArray.length)];
                usedSet.add(term);
                return term;
            }

            // Pick random unused term
            const term = unusedTerms[Math.floor(Math.random() * unusedTerms.length)];
            usedSet.add(term);

            // Limit set size
            if (usedSet.size > MAX_USED_TERMS) {
                // Remove oldest entries (convert to array, remove first few)
                const arr = Array.from(usedSet);
                arr.slice(0, 5).forEach(t => usedSet.delete(t));
            }

            return term;
        }

        // Cache for Met object IDs - with limited size to allow variety
        const metSearchCache = new Map();
        const MAX_CACHE_SIZE = 50; // Limit cache to allow fresh searches

        // Fetch random public domain objects from Met Museum
        async function fetchMetArtworks(count = 10, searchQuery = '', filters = {}) {
            try {
                let url = `${MET_API_BASE}/search?hasImages=true&isPublicDomain=true`;

                // Build search query with randomization
                let q = searchQuery;

                if (!q) {
                    // For explore mode, use rotating random search terms for maximum variety
                    q = getRandomSearchTerm(usedSearchTerms, RANDOM_SEARCH_TERMS);
                } else {
                    // Expand user's search query with synonyms for better results
                    const expandedTerms = getExpandedTermsArray(searchQuery);
                    if (expandedTerms.length > 1) {
                        // Use original + top synonyms (Met does full-text search)
                        q = expandedTerms.slice(0, 4).join(' ');
                    }
                }

                // Ensure we have a valid search term
                if (!q || q.trim() === '') {
                    q = 'painting';
                }

                // Don't add medium to search query - it makes AND search too restrictive
                // Medium filtering is done in normalizeMetArtwork instead

                url += `&q=${encodeURIComponent(q)}`;

                // Period filtering is done via post-filtering on artwork metadata

                // Only sometimes add department filter (50% chance) to allow for variety
                // This prevents empty results when search term + department have no overlap
                if (!searchQuery && !filters.medium && Math.random() > 0.5) {
                    const randomDept = MET_DEPARTMENTS[Math.floor(Math.random() * MET_DEPARTMENTS.length)];
                    url += `&departmentId=${randomDept}`;
                }

                // Check memory cache first, then localStorage cache
                let objectIDs;
                const cacheKey = `search_${encodeURIComponent(url)}`;

                if (metSearchCache.has(url)) {
                    objectIDs = metSearchCache.get(url);
                } else {
                    // Limit memory cache size
                    if (metSearchCache.size >= MAX_CACHE_SIZE) {
                        const firstKey = metSearchCache.keys().next().value;
                        metSearchCache.delete(firstKey);
                    }

                    try {
                        const data = await fetchWithBackoff(url, cacheKey);

                        if (!data.objectIDs || data.objectIDs.length === 0) {
                            // Fallback: try a simpler search with just 'painting'
                            const fallbackUrl = `${MET_API_BASE}/search?hasImages=true&isPublicDomain=true&q=painting`;
                            const fallbackData = await fetchWithBackoff(fallbackUrl, `search_painting`);
                            if (fallbackData.objectIDs && fallbackData.objectIDs.length > 0) {
                                objectIDs = fallbackData.objectIDs;
                                metSearchCache.set(fallbackUrl, objectIDs);
                            } else {
                                // Met API not returning results - mark as unavailable and fall back to Wikimedia
                                metApiAvailable = false;
                                return [];
                            }
                        } else {
                            objectIDs = data.objectIDs;
                            metSearchCache.set(url, objectIDs);
                            metApiAvailable = true;
                        }
                    } catch (error) {
                        console.error('Met API search failed:', error);
                        metApiAvailable = false;
                        return []; // Will trigger Wikimedia fallback
                    }
                }

                // TRUE random selection with multiple randomization techniques
                // 1. Random starting offset (anywhere in the result set)
                const maxOffset = Math.max(0, objectIDs.length - count * 3);
                const randomOffset = Math.floor(Math.random() * maxOffset);

                // 2. Fisher-Yates shuffle for truly random selection
                const shuffled = [...objectIDs];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }

                // 3. Take from random offset with random skip pattern
                // Fetch more when filters are active since post-filtering will discard many
                const hasFilters = filters.medium || filters.period;
                const multiplier = hasFilters ? 5 : 2;
                const targetCount = Math.min(count * multiplier, hasFilters ? 80 : 40);
                const skipPattern = Math.floor(Math.random() * 3) + 1; // Skip 1-3 items
                const selectedIds = [];
                for (let i = randomOffset; i < shuffled.length && selectedIds.length < targetCount; i += skipPattern) {
                    selectedIds.push(shuffled[i]);
                }
                // Fill remaining if needed
                for (let i = 0; selectedIds.length < targetCount && i < shuffled.length; i++) {
                    if (!selectedIds.includes(shuffled[i])) {
                        selectedIds.push(shuffled[i]);
                    }
                }

                // Fetch object details in controlled parallel batches
                const batches = [];
                for (let i = 0; i < selectedIds.length; i += PARALLEL_REQUESTS) {
                    batches.push(selectedIds.slice(i, i + PARALLEL_REQUESTS));
                }

                // Process batches sequentially with delay, objects within each batch in parallel
                const results = [];
                for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                    const batch = batches[batchIndex];
                    const batchResults = await Promise.all(
                        batch.map(id => fetchMetObjectDetails(id, filters, searchQuery))
                    );
                    results.push(batchResults);

                    // Add delay between batches (not after last batch)
                    if (batchIndex < batches.length - 1) {
                        await delay(BATCH_DELAY_MS);
                    }
                }

                // Flatten (2 levels deep), filter, and sort by priority (lower score = shown first = older art preferred)
                const artworks = results.flat(2)
                    .filter(a => a !== null)
                    .sort((a, b) => {
                        // When searching, sort by relevance (higher is better)
                        if (searchQuery) {
                            const relevanceDiff = (b.searchRelevance || 0) - (a.searchRelevance || 0);
                            if (relevanceDiff !== 0) return relevanceDiff;
                        }
                        // Then by priority score (lower is better)
                        return (a.priorityScore || 50) - (b.priorityScore || 50);
                    });

                return artworks.slice(0, count);
            } catch (error) {
                console.error('Error fetching Met artworks:', error);
                return [];
            }
        }

        async function fetchMetObjectDetails(objectId, filters = {}, searchQuery = '') {
            try {
                const cacheKey = `obj_${objectId}`;
                const obj = await fetchWithBackoff(`${MET_API_BASE}/objects/${objectId}`, cacheKey);

                // Only include public domain works with images
                if (!obj.isPublicDomain || !obj.primaryImage) return null;

                // ONLY apply period filter if user explicitly selected a time period
                // If no period filter, show ALL artworks including those without dates
                const hasPeriodFilter = filters.period && filters.period !== '' && PERIOD_RANGES[filters.period];

                if (hasPeriodFilter) {
                    const range = PERIOD_RANGES[filters.period];

                    // Met API provides objectBeginDate and objectEndDate as numbers
                    const beginYear = obj.objectBeginDate;
                    const endYear = obj.objectEndDate;

                    // If we have numeric dates from the API, use them (more reliable)
                    if (typeof beginYear === 'number' && typeof endYear === 'number') {
                        // Check if the artwork's date range overlaps with the filter range
                        if (endYear < range.start || beginYear > range.end) {
                            return null;
                        }
                    } else {
                        // Fallback: try to extract year from objectDate string
                        const year = extractYear(obj.objectDate);
                        if (year !== null) {
                            if (year < range.start || year > range.end) return null;
                        } else {
                            // Can't determine date but user wants specific period - skip
                            return null;
                        }
                    }
                }
                // If no period filter is set, we include the artwork regardless of whether it has a date

                // Apply medium filter (only if selected)
                const hasMediumFilter = filters.medium && filters.medium !== '' && MEDIUM_KEYWORDS[filters.medium];

                if (hasMediumFilter) {
                    const mediumLower = (obj.medium || '').toLowerCase();
                    const classification = (obj.classification || '').toLowerCase();
                    const objectName = (obj.objectName || '').toLowerCase();
                    const hasMatch = MEDIUM_KEYWORDS[filters.medium].some(kw =>
                        mediumLower.includes(kw) || classification.includes(kw) || objectName.includes(kw)
                    );
                    if (!hasMatch) return null;
                }

                return normalizeMetArtwork(obj, searchQuery);
            } catch (error) {
                return null;
            }
        }

        // Check if an artwork is photography based on metadata
        function isPhotography(obj) {
            const medium = (obj.medium || '').toLowerCase();
            const classification = (obj.classification || '').toLowerCase();
            const department = (obj.department || '').toLowerCase();
            const objectName = (obj.objectName || '').toLowerCase();

            const photoKeywords = [
                'photograph', 'photography', 'photo', 'gelatin silver', 'albumen',
                'daguerreotype', 'calotype', 'tintype', 'ambrotype', 'cyanotype',
                'photogravure', 'chromogenic', 'polaroid', 'silver print', 'platinum print',
                'photographic'
            ];

            return photoKeywords.some(kw =>
                medium.includes(kw) || classification.includes(kw) ||
                department.includes(kw) || objectName.includes(kw)
            );
        }

        // Calculate a priority score for artwork (lower = better, will be shown first)
        // This deboosts modern art (post-1980) and heavily deboosts post-2000
        // Returns null if artwork should be excluded (undated photography)
        function getArtworkPriorityScore(obj) {
            try {
                const beginYear = obj.objectBeginDate;
                const endYear = obj.objectEndDate;

                // Use the end date if available, otherwise try to extract from objectDate
                let year = endYear || beginYear;
                if ((!year || typeof year !== 'number') && obj.objectDate) {
                    year = extractYear(obj.objectDate);
                }

                const isPhoto = isPhotography(obj);

                if (!year || typeof year !== 'number') {
                    // Unknown/undated artwork
                    if (isPhoto) {
                        // Exclude undated photography entirely
                        return null;
                    } else {
                        // Undated fine art - include with slight deboost (priority 60-75)
                        return 60 + Math.random() * 15;
                    }
                }

                if (year > 2000) {
                    // Heavily deboost post-2000 art (priority 200-300)
                    return 200 + Math.random() * 100;
                } else if (year > 1980) {
                    // Deboost 1980-2000 art (priority 100-150)
                    return 100 + Math.random() * 50;
                } else if (year > 1900) {
                    // Slight deboost for 1900-1980 (priority 40-60)
                    return 40 + Math.random() * 20;
                } else {
                    // Pre-1900 art gets best priority (0-40)
                    // Older is slightly better
                    const ageFactor = Math.max(0, (1900 - year) / 100);
                    return Math.random() * 30 + Math.max(0, 10 - ageFactor * 10);
                }
            } catch (e) {
                // If anything goes wrong, return slight deboost priority
                return 60 + Math.random() * 15;
            }
        }

        // Calculate search relevance score (higher = more relevant)
        function calculateSearchRelevance(artwork, searchQuery) {
            if (!searchQuery || searchQuery.trim() === '') return 100; // No query = all relevant

            const query = searchQuery.toLowerCase().trim();
            const queryWords = query.split(/\s+/).filter(w => w.length > 2);

            let score = 0;
            const title = (artwork.title || '').toLowerCase();
            const artist = (artwork.artist || artwork.artistDisplayName || '').toLowerCase();
            const classification = (artwork.classification || '').toLowerCase();
            const culture = (artwork.culture || '').toLowerCase();
            const period = (artwork.period || '').toLowerCase();
            const department = (artwork.department || '').toLowerCase();
            const medium = (artwork.medium || '').toLowerCase();
            const tags = (artwork.tags || []).map(t => (t.term || t).toLowerCase()).join(' ');

            // Exact phrase match in title (highest value)
            if (title.includes(query)) score += 100;

            // Exact phrase match in artist
            if (artist.includes(query)) score += 80;

            // Word matches in title
            queryWords.forEach(word => {
                if (title.includes(word)) score += 30;
            });

            // Word matches in artist
            queryWords.forEach(word => {
                if (artist.includes(word)) score += 25;
            });

            // Word matches in classification/culture/period (subject-related)
            queryWords.forEach(word => {
                if (classification.includes(word)) score += 20;
                if (culture.includes(word)) score += 20;
                if (period.includes(word)) score += 15;
                if (tags.includes(word)) score += 15;
            });

            // Word matches in medium/department (less relevant)
            queryWords.forEach(word => {
                if (medium.includes(word)) score += 5;
                if (department.includes(word)) score += 5;
            });

            return score;
        }

        // Check if artwork is relevant to search query (minimum threshold)
        function isRelevantToSearch(artwork, searchQuery) {
            if (!searchQuery || searchQuery.trim() === '') return true;

            const query = searchQuery.toLowerCase().trim();
            const queryWords = query.split(/\s+/).filter(w => w.length > 2);

            const title = (artwork.title || '').toLowerCase();
            const artist = (artwork.artist || artwork.artistDisplayName || '').toLowerCase();
            const classification = (artwork.classification || '').toLowerCase();
            const culture = (artwork.culture || '').toLowerCase();
            const period = (artwork.period || '').toLowerCase();
            const medium = (artwork.medium || '').toLowerCase();
            const tags = (artwork.tags || []).map(t => (t.term || t).toLowerCase()).join(' ');
            const objectName = (artwork.objectName || '').toLowerCase();

            // Must match at least one query word in a relevant field
            const relevantText = `${title} ${artist} ${classification} ${culture} ${period} ${tags} ${objectName}`;

            // Check if any query word appears in relevant fields
            return queryWords.some(word => relevantText.includes(word)) ||
                   relevantText.includes(query);
        }

        function normalizeMetArtwork(obj, searchQuery = '') {
            // Calculate priority score first - if null, exclude this artwork (undated photography)
            const priorityScore = getArtworkPriorityScore(obj);
            if (priorityScore === null) {
                return null;
            }

            // Check search relevance BEFORE normalizing (to save processing)
            if (searchQuery && !isRelevantToSearch(obj, searchQuery)) {
                return null;
            }

            const artistDates = [obj.artistBeginDate, obj.artistEndDate]
                .filter(d => d)
                .join('');

            // Extract just the nationality (first part before comma or parenthesis)
            let nationality = obj.artistNationality || null;
            if (nationality) {
                // "French" from "French, born Paris" or just "French"
                nationality = nationality.split(',')[0].split('(')[0].trim();
            }

            // Calculate search relevance score
            const searchRelevance = calculateSearchRelevance(obj, searchQuery);

            // Use primaryImage for high quality (Met images are typically 1000-4000px)
            return {
                priorityScore,
                searchRelevance,
                uniqueId: `met_${obj.objectID}`,
                source: 'met',
                sourceUrl: obj.objectURL,
                imageUrl: obj.primaryImage,
                thumbnailUrl: obj.primaryImage,
                title: obj.title || 'Untitled',
                artist: obj.artistDisplayName || 'Unknown Artist',
                artistNationality: nationality,
                artistDates: artistDates || null,
                // Skip artistDisplayBio as it duplicates nationality/dates info
                date: obj.objectDate || null,
                medium: obj.medium || null,
                dimensions: obj.dimensions || null,
                classification: obj.classification || null,
                department: obj.department || null,
                culture: obj.culture || null,
                period: obj.period || null,
                dynasty: obj.dynasty || null,
                creditLine: obj.creditLine || null,
                geographyType: obj.geographyType || null,
                city: obj.city || null,
                country: obj.country || null,
                region: obj.region || null,
                repository: 'The Metropolitan Museum of Art',
                accessionNumber: obj.accessionNumber || null,
                isPublicDomain: true
            };
        }

        // Extended Wikimedia search terms for variety
        const WIKI_SEARCH_TERMS = [
            // By genre/type
            'painting portrait', 'painting landscape', 'oil painting', 'masterpiece',
            'famous painting', 'genre painting', 'still life painting', 'marine painting',
            'animal painting', 'figurative art', 'battle painting', 'equestrian painting',
            'court painting', 'history painting', 'allegory painting', 'nude painting',
            // By movement/style
            'classical art', 'renaissance art', 'impressionist', 'baroque painting',
            'romantic painting', 'realist painting', 'academic art', 'neoclassical painting',
            'mannerist', 'pre-raphaelite', 'symbolist painting', 'orientalist painting',
            'rococo painting', 'naturalist painting', 'post-impressionist',
            // By nationality
            'dutch master', 'italian painting', 'french painting', 'flemish painting',
            'spanish painting', 'german painting', 'english painting', 'american painting',
            'russian painting', 'scandinavian painting', 'austrian painting',
            // By subject
            'religious painting', 'mythological painting', 'historical painting',
            'biblical scene', 'madonna painting', 'saint painting', 'angel painting',
            'crucifixion art', 'nativity art', 'annunciation art',
            // By artist type
            'old master', 'grand manner', 'academy painting', 'salon painting',
            // By setting
            'interior painting', 'exterior scene', 'domestic scene', 'pastoral scene',
            'village scene', 'cityscape', 'seascape', 'moonlight painting'
        ];

        // Fetch public domain images from Wikimedia Commons
        async function fetchWikimediaArtworks(count = 10, searchQuery = '', filters = {}) {
            try {
                // Build category search
                let categories = ['Category:Public domain paintings'];

                // For Wikimedia, we only want fine art - NO photography (photos come from Met only)
                if (filters.medium && filters.medium !== 'photographs') {
                    const categoryMap = {
                        'paintings': 'Category:Public domain paintings',
                        'drawings': 'Category:Public domain drawings',
                        'prints': 'Category:Public domain prints',
                        'etchings': 'Category:Public domain etchings',
                        'woodcuts': 'Category:Woodcuts',
                        'watercolors': 'Category:Watercolor paintings'
                    };
                    categories = [categoryMap[filters.medium] || 'Category:Public domain paintings'];
                } else if (filters.medium === 'photographs') {
                    // Don't fetch photos from Wikimedia - return empty
                    return [];
                }

                // Use search API with filters - add randomization
                let searchTerm = searchQuery;

                if (!searchTerm) {
                    // Use rotating random search terms for maximum variety
                    searchTerm = getRandomSearchTerm(usedWikiTerms, WIKI_SEARCH_TERMS);
                } else {
                    // Expand user's search query with synonyms for better results
                    const expandedTerms = getExpandedTermsArray(searchQuery);
                    if (expandedTerms.length > 1) {
                        searchTerm = expandedTerms.slice(0, 4).join(' ');
                    }
                }

                // Period filtering is done via post-filtering on artwork metadata

                // Use smaller random offset for search queries to avoid going past results
                // Larger offset only for explore mode (no search query)
                const randomOffset = searchQuery
                    ? Math.floor(Math.random() * 20)  // Small offset for searches
                    : Math.floor(Math.random() * 500); // Large offset for explore

                // Fetch more when filters are active since post-filtering will discard many
                const hasFilters = filters.medium || filters.period;
                const fetchMultiplier = hasFilters ? 5 : 3;

                const params = new URLSearchParams({
                    action: 'query',
                    format: 'json',
                    origin: '*',
                    generator: 'search',
                    gsrsearch: `${searchTerm} filetype:bitmap`,
                    gsrnamespace: '6', // File namespace
                    gsrlimit: String(Math.min(count * fetchMultiplier, 50)), // Fetch more for filtering
                    gsroffset: String(randomOffset), // Large random offset for variety
                    prop: 'imageinfo|categories',
                    iiprop: 'url|extmetadata|size|mime',
                    iiurlwidth: '1200',
                    cllimit: '10'
                });

                const response = await fetch(`${WIKIMEDIA_API_BASE}?${params}`);
                if (!response.ok) throw new Error('Wikimedia API request failed');

                const data = await response.json();
                if (!data.query || !data.query.pages) return [];

                // Shuffle results for more variety
                const pages = Object.values(data.query.pages).sort(() => Math.random() - 0.5);

                const artworks = pages
                    .map(page => normalizeWikimediaArtwork(page, filters))
                    .filter(a => a !== null)
                    .slice(0, count);

                return artworks;
            } catch (error) {
                console.error('Error fetching Wikimedia artworks:', error);
                return [];
            }
        }

        function normalizeWikimediaArtwork(page, filters = {}) {
            if (!page.imageinfo || !page.imageinfo[0]) return null;

            const info = page.imageinfo[0];
            const meta = info.extmetadata || {};

            // Skip non-images
            if (!info.mime || !info.mime.startsWith('image/')) return null;

            // Skip non-web-compatible formats (TIFF, etc.) - browsers can't display these
            const url = info.url || '';
            const urlLower = url.toLowerCase();
            if (urlLower.endsWith('.tif') || urlLower.endsWith('.tiff') ||
                urlLower.endsWith('.bmp') || urlLower.endsWith('.psd') ||
                info.mime === 'image/tiff' || info.mime === 'image/x-tiff') {
                return null;
            }

            // Skip small images (likely thumbnails or icons)
            if (info.width && info.width < 300) return null;
            if (info.height && info.height < 300) return null;

            // EXCLUDE PHOTOGRAPHY from Wikimedia - we only want fine art here
            // Photos should come from Met Museum's curated photography collection
            const pageTitleLower = (page.title || '').toLowerCase();
            const categoriesLower = (meta.Categories?.value || '').toLowerCase();
            const mediumLower = (meta.Medium?.value || '').toLowerCase();

            const photoKeywords = [
                'photograph', 'photography', 'photo', 'gelatin silver', 'albumen',
                'daguerreotype', 'calotype', 'tintype', 'ambrotype', 'cyanotype',
                'photogravure', 'chromogenic', 'polaroid', 'camera', 'snapshot',
                'photographic print', 'silver print', 'platinum print'
            ];

            const isPhotograph = photoKeywords.some(kw =>
                pageTitleLower.includes(kw) || categoriesLower.includes(kw) || mediumLower.includes(kw)
            );

            if (isPhotograph) return null;

            // EXCLUDE non-art content (scientific diagrams, maps, charts, logos, etc.)
            const descriptionLower = (meta.ImageDescription?.value || '').toLowerCase();
            const authorLower = (meta.Artist?.value || '').toLowerCase();
            const allTextLower = pageTitleLower + ' ' + categoriesLower + ' ' + descriptionLower + ' ' + authorLower;

            const nonArtKeywords = [
                // Scientific/Technical
                'diagram', 'chart', 'graph', 'map', 'satellite', 'radar', 'infrared',
                'meteorological', 'weather', 'climate', 'scientific', 'technical',
                'schematic', 'blueprint', 'floor plan', 'cross section', 'cross-section',
                // Government/Institutional sources
                'noaa', 'nasa', 'usgs', 'u.s. government', 'u. s. government',
                'national oceanic', 'atmospheric administration', 'geological survey',
                'census bureau', 'federal', 'agency', 'department of',
                // Other non-art
                'logo', 'icon', 'flag', 'coat of arms', 'heraldry', 'emblem', 'badge',
                'screenshot', 'screen shot', 'interface', 'software',
                'specimen', 'microscope', 'x-ray', 'xray', 'medical', 'anatomy',
                'botanical illustration', 'scientific illustration', 'technical drawing',
                'patent', 'trademark', 'advertisement', 'poster design',
                'currency', 'banknote', 'coin design', 'stamp design',
                'animation', 'gif', 'meme'
            ];

            const isNonArt = nonArtKeywords.some(kw => allTextLower.includes(kw));
            if (isNonArt) return null;

            // REQUIRE art-related categories or content
            const artIndicators = [
                'painting', 'painter', 'artist', 'artwork', 'fine art', 'art museum',
                'gallery', 'portrait', 'landscape painting', 'oil on canvas', 'oil on panel',
                'watercolor', 'watercolour', 'fresco', 'tempera', 'acrylic',
                'drawing', 'sketch', 'etching', 'engraving', 'lithograph', 'woodcut',
                'sculpture', 'statue', 'bust', 'relief',
                'renaissance', 'baroque', 'impressionist', 'romanticism', 'realism',
                'masterpiece', 'museum', 'collection'
            ];

            const hasArtIndicator = artIndicators.some(kw => allTextLower.includes(kw));
            if (!hasArtIndicator) return null;

            // Apply medium filter if selected (backup for category-based filtering)
            if (filters.medium && filters.medium !== '' && MEDIUM_KEYWORDS[filters.medium]) {
                if (filters.medium !== 'photographs') {
                    const hasMatch = MEDIUM_KEYWORDS[filters.medium].some(kw =>
                        pageTitleLower.includes(kw) || categoriesLower.includes(kw) || mediumLower.includes(kw)
                    );
                    if (!hasMatch) return null;
                }
            }

            // Check for public domain license
            const license = meta.LicenseShortName?.value || '';
            const usageTerms = meta.UsageTerms?.value || '';
            const copyrightStatus = meta.Copyrighted?.value || '';

            const isPublicDomain =
                license.toLowerCase().includes('public domain') ||
                license.includes('CC0') ||
                license.includes('PDM') ||
                usageTerms.toLowerCase().includes('public domain') ||
                copyrightStatus === 'False';

            if (!isPublicDomain) return null;

            // ONLY apply period filter if user explicitly selected a time period
            // If no period filter, show ALL artworks including those without dates
            const hasPeriodFilter = filters.period && filters.period !== '' && PERIOD_RANGES[filters.period];

            if (hasPeriodFilter) {
                const range = PERIOD_RANGES[filters.period];
                const dateStr = meta.DateTimeOriginal?.value || meta.DateTime?.value || '';
                const year = extractYear(dateStr);

                if (year !== null) {
                    // If we found a year, validate it's in range
                    if (year < range.start || year > range.end) return null;
                } else {
                    // For Wikimedia, try to infer from categories or description
                    const allText = (page.title || '') + ' ' + (meta.ImageDescription?.value || '') + ' ' + (meta.Categories?.value || '');
                    const inferredYear = extractYear(allText);

                    if (inferredYear !== null) {
                        if (inferredYear < range.start || inferredYear > range.end) return null;
                    }
                    // If we still can't determine date, let it through - search keywords should help
                }
            }
            // If no period filter is set, include the artwork regardless of whether it has a date

            // Extract artist info using improved cleaning
            const artistInfo = meta.Artist?.value || '';
            const artistName = extractWikimediaArtist(artistInfo);
            const artistDatesMatch = artistInfo.match(/\((\d{4})\s*[-]\s*(\d{4})\)/);
            const artistDates = artistDatesMatch ? `${artistDatesMatch[1]}${artistDatesMatch[2]}` : null;

            // Extract clean title
            const pageTitle = page.title || '';
            const objectName = meta.ObjectName?.value || '';
            const title = extractWikimediaTitle(objectName, pageTitle);

            // Clean other metadata fields
            const rawDate = meta.DateTimeOriginal?.value || meta.DateTime?.value || null;
            const cleanDate = cleanWikimediaText(rawDate);

            const rawMedium = meta.Medium?.value || null;
            const cleanMedium = cleanWikimediaText(rawMedium);

            const rawDescription = meta.ImageDescription?.value || null;
            const cleanDescription = cleanWikimediaText(rawDescription);

            const rawCredit = meta.Credit?.value || null;
            const cleanCredit = cleanWikimediaText(rawCredit);

            const rawRepository = meta.Repository?.value || 'Wikimedia Commons';
            const cleanRepository = cleanWikimediaText(rawRepository) || 'Wikimedia Commons';

            // Use full resolution URL for better quality, thumburl for display
            const imageUrl = info.url;
            const thumbnailUrl = info.thumburl || info.url;

            // Calculate priority score (deboost modern art, slight deboost for undated)
            const dateForPriority = cleanDate ? extractYear(cleanDate) : null;
            let priorityScore;
            if (!dateForPriority) {
                // Undated fine art - slight deboost (priority 60-75)
                priorityScore = 60 + Math.random() * 15;
            } else if (dateForPriority > 2000) {
                priorityScore = 200 + Math.random() * 100;
            } else if (dateForPriority > 1980) {
                priorityScore = 100 + Math.random() * 50;
            } else if (dateForPriority > 1900) {
                priorityScore = 40 + Math.random() * 20;
            } else {
                const ageFactor = Math.max(0, (1900 - dateForPriority) / 100);
                priorityScore = Math.random() * 30 + Math.max(0, 10 - ageFactor * 10);
            }

            return {
                priorityScore,
                uniqueId: `wiki_${page.pageid}`,
                source: 'wikimedia',
                sourceUrl: info.descriptionurl,
                imageUrl: imageUrl,
                thumbnailUrl: imageUrl,
                title: title,
                artist: artistName,
                artistNationality: null,
                artistDates: artistDates,
                artistBio: null,
                date: cleanDate,
                medium: cleanMedium,
                dimensions: rawDescription?.match(/\d+\s*[x]\s*\d+\s*cm/i)?.[0] || null,
                classification: null,
                department: null,
                culture: null,
                period: null,
                dynasty: null,
                creditLine: cleanCredit,
                geographyType: null,
                city: null,
                country: null,
                region: null,
                repository: cleanRepository,
                accessionNumber: null,
                description: cleanDescription && cleanDescription.length < 500 ? cleanDescription : null,
                license: license,
                isPublicDomain: true
            };
        }

        // Helper functions
        function getSourceDisplayName(source) {
            const sourceNames = {
                'met': 'Met Museum',
                'aic': 'Art Institute Chicago',
                'cleveland': 'Cleveland Museum',
                'wikimedia': 'Wikimedia'
            };
            return sourceNames[source] || source;
        }

        function stripHtml(str) {
            if (!str) return null;
            const div = document.createElement('div');
            div.innerHTML = str;
            return div.textContent || div.innerText || str;
        }

        // Clean Wikimedia metadata that contains QS labels and multilingual data
        function cleanWikimediaText(str) {
            if (!str) return null;

            // First strip HTML
            let cleaned = stripHtml(str);
            if (!cleaned) return null;

            // Remove QS patterns like "title QS:P1476,de:" or "label QS:Lde,"
            cleaned = cleaned.replace(/\s*(title|label)\s*QS:[^\s,]+,?/gi, ' ');

            // Remove language codes like "German:" at the start
            cleaned = cleaned.replace(/^[A-Za-z]+:\s*/i, '');

            // Remove patterns like "QS:Len," "QS:Lde," etc.
            cleaned = cleaned.replace(/QS:L[a-z-]+,?"?[^"]*"?/gi, '');

            // Remove any remaining QS: patterns
            cleaned = cleaned.replace(/QS:[^\s]+/gi, '');

            // Remove wiki template patterns like {{...}}
            cleaned = cleaned.replace(/\{\{[^}]*\}\}/g, '');

            // Remove multiple spaces and trim
            cleaned = cleaned.replace(/\s+/g, ' ').trim();

            // If there are multiple similar titles separated by spaces, take the first clean one
            // This handles cases like "Mona Lisa Mona Lisa..."
            const words = cleaned.split(' ');
            if (words.length > 4) {
                // Check for repeated patterns
                const firstTwo = words.slice(0, 2).join(' ');
                const nextTwo = words.slice(2, 4).join(' ');
                if (firstTwo === nextTwo) {
                    cleaned = firstTwo;
                }
            }

            // If result is too short or empty, return null
            if (!cleaned || cleaned.length < 2) return null;

            return cleaned;
        }

        // Extract clean English title from Wikimedia metadata
        function extractWikimediaTitle(objectName, pageTitle) {
            // Try to get the English label if present
            if (objectName) {
                // Look for English label pattern
                const enMatch = objectName.match(/label\s*QS:Len,\s*"([^"]+)"/i);
                if (enMatch) return enMatch[1];

                // Look for simple quoted title
                const quotedMatch = objectName.match(/"([^"]+)"/);
                if (quotedMatch && quotedMatch[1].length > 2 && !quotedMatch[1].includes('QS:')) {
                    return quotedMatch[1];
                }
            }

            // Clean the objectName
            const cleanedName = cleanWikimediaText(objectName);
            if (cleanedName && cleanedName.length > 2 && cleanedName.length < 200) {
                return cleanedName;
            }

            // Fall back to cleaned page title
            const cleanTitle = pageTitle
                .replace('File:', '')
                .replace(/\.[^.]+$/, '')
                .replace(/_/g, ' ')
                .replace(/\s*-\s*(WGA|Google Art Project|crop).*$/i, '')
                .trim();

            return cleanTitle || 'Untitled';
        }

        // Extract clean artist name from Wikimedia metadata
        function extractWikimediaArtist(artistInfo) {
            if (!artistInfo) return 'Unknown Artist';

            // Strip HTML first
            let artist = stripHtml(artistInfo);
            if (!artist) return 'Unknown Artist';

            // Remove common wiki patterns
            artist = artist
                .replace(/\{\{[^}]*\}\}/g, '')
                .replace(/\[\[[^\]]*\|([^\]]+)\]\]/g, '$1')
                .replace(/\[\[([^\]]+)\]\]/g, '$1')
                .replace(/QS:[^\s]+/gi, '')
                .trim();

            // Take text before parentheses (life dates)
            const parenIndex = artist.indexOf('(');
            if (parenIndex > 0) {
                artist = artist.substring(0, parenIndex).trim();
            }

            // Remove trailing/leading punctuation
            artist = artist.replace(/^[,.\s]+|[,.\s]+$/g, '');

            if (!artist || artist.length < 2) return 'Unknown Artist';

            return artist;
        }

        function extractYear(dateStr) {
            if (dateStr === null || dateStr === undefined) return null;

            // Handle numeric input (from Met API)
            if (typeof dateStr === 'number') {
                return dateStr;
            }

            // Convert to string
            const str = String(dateStr);

            // Handle negative years (BCE)
            const bceMatch = str.match(/(\d+)\s*(BCE|BC|B\.C\.)/i);
            if (bceMatch) return -parseInt(bceMatch[1]);

            // Handle century mentions like "19th century" or "20th-century"
            const centuryMatch = str.match(/(\d{1,2})(?:st|nd|rd|th)[\s-]*century/i);
            if (centuryMatch) {
                // "19th century" = 1800s, "20th century" = 1900s
                const century = parseInt(centuryMatch[1]);
                return (century - 1) * 100 + 50; // Return middle of century
            }

            // Handle decade mentions like "1920s"
            const decadeMatch = str.match(/(\d{4})s/);
            if (decadeMatch) {
                return parseInt(decadeMatch[1]) + 5; // Return middle of decade
            }

            // Handle date ranges like "1850-1860" or "18501860" - take the middle
            const rangeMatch = str.match(/(\d{4})\s*[-]\s*(\d{4})/);
            if (rangeMatch) {
                const start = parseInt(rangeMatch[1]);
                const end = parseInt(rangeMatch[2]);
                return Math.floor((start + end) / 2);
            }

            // Handle "circa" or "c." dates
            const circaMatch = str.match(/(?:circa|ca?\.?)\s*(\d{3,4})/i);
            if (circaMatch) {
                return parseInt(circaMatch[1]);
            }

            // Handle regular 4-digit years
            const yearMatch = str.match(/\b(1[0-9]{3}|20[0-2][0-9])\b/);
            if (yearMatch) {
                return parseInt(yearMatch[1]);
            }

            // Handle 3-digit years (ancient/medieval)
            const ancientMatch = str.match(/\b([1-9][0-9]{2})\b/);
            if (ancientMatch) {
                const year = parseInt(ancientMatch[1]);
                // Only return if it looks like a plausible historical year
                if (year >= 100 && year <= 999) {
                    return year;
                }
            }

            return null;
        }

        // Duplicate detection
        function generateDuplicateKey(artwork) {
            const title = (artwork.title || '').toLowerCase().replace(/[^a-z0-9]/g, '');
            const artist = (artwork.artist || '').toLowerCase().replace(/[^a-z0-9]/g, '');
            return `${title}_${artist}`;
        }

        function isDuplicate(artwork, seenSet) {
            const key = generateDuplicateKey(artwork);
            if (seenSet.has(key) || seenSet.has(artwork.uniqueId)) {
                return true;
            }
            seenSet.add(key);
            seenSet.add(artwork.uniqueId);
            return false;
        }

        // ===== Rendering =====
        function createTile(artwork) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.dataset.id = artwork.uniqueId;

            // Build artist info line without duplication
            const artistInfoParts = [];
            if (artwork.artistNationality) {
                // Extract just the country, not the full bio
                const nationality = artwork.artistNationality.split(',')[0].trim();
                artistInfoParts.push(nationality);
            }
            if (artwork.artistDates) {
                artistInfoParts.push(artwork.artistDates);
            }
            const artistInfoLine = artistInfoParts.join(', ');

            tile.innerHTML = `
                <div class="tile-inner">
                    <div class="tile-front">
                        <div class="tile-image-container">
                            <img class="tile-image" src="${artwork.thumbnailUrl}" alt="${escapeHtml(artwork.title)}" loading="lazy" onerror="console.warn('Image failed:', this.src); this.parentElement.parentElement.parentElement.parentElement.remove()">
                            <div class="tile-actions">
                                <button class="tile-action-btn save-btn ${isArtworkSaved(artwork.uniqueId, artwork.source) ? 'saved' : ''}" aria-label="Save artwork">
                                    <svg viewBox="0 0 24 24">
                                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                                    </svg>
                                </button>
                                <button class="tile-action-btn download-btn" aria-label="Download image">
                                    <svg viewBox="0 0 24 24">
                                        <path d="M12 15V3m0 12l-4-4m4 4l4-4M2 17l.621 2.485A2 2 0 0 0 4.561 21h14.878a2 2 0 0 0 1.94-1.515L22 17" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </button>
                            </div>
                            <a href="${artwork.sourceUrl}" target="_blank" rel="noopener noreferrer" class="source-badge" title="View on ${getSourceDisplayName(artwork.source)}">${getSourceDisplayName(artwork.source)}</a>
                            <div class="tile-overlay">
                                <div class="tile-title-preview">${escapeHtml(artwork.title)}</div>
                                <div class="tile-artist-preview">${escapeHtml(artwork.artist)}</div>
                            </div>
                        </div>
                    </div>
                    <div class="tile-back">
                        <div class="placard">
                            <div class="placard-title">${escapeHtml(artwork.title)}</div>
                            <div class="placard-artist">${escapeHtml(artwork.artist)}</div>
                            ${artistInfoLine ? `
                                <div class="placard-artist-dates">${escapeHtml(artistInfoLine)}</div>
                            ` : ''}

                            <div class="placard-divider"></div>

                            ${artwork.date ? `
                                <div class="placard-field">
                                    <div class="placard-label">Date</div>
                                    <div class="placard-value">${artwork.date}</div>
                                </div>
                            ` : ''}

                            ${artwork.medium ? `
                                <div class="placard-field">
                                    <div class="placard-label">Medium</div>
                                    <div class="placard-value">${artwork.medium}</div>
                                </div>
                            ` : ''}

                            ${artwork.dimensions ? `
                                <div class="placard-field">
                                    <div class="placard-label">Dimensions</div>
                                    <div class="placard-value">${artwork.dimensions}</div>
                                </div>
                            ` : ''}

                            ${artwork.classification ? `
                                <div class="placard-field">
                                    <div class="placard-label">Classification</div>
                                    <div class="placard-value">${artwork.classification}</div>
                                </div>
                            ` : ''}

                            ${artwork.culture || artwork.period || artwork.dynasty ? `
                                <div class="placard-field">
                                    <div class="placard-label">Period / Culture</div>
                                    <div class="placard-value">${[artwork.period, artwork.culture, artwork.dynasty].filter(Boolean).join('  ')}</div>
                                </div>
                            ` : ''}

                            ${artwork.department ? `
                                <div class="placard-field">
                                    <div class="placard-label">Department</div>
                                    <div class="placard-value">${artwork.department}</div>
                                </div>
                            ` : ''}

                            ${artwork.description ? `
                                <div class="placard-divider"></div>
                                <div class="placard-field">
                                    <div class="placard-description">${artwork.description.substring(0, 300)}${artwork.description.length > 300 ? '...' : ''}</div>
                                </div>
                            ` : ''}

                            <div class="placard-divider"></div>

                            <div class="placard-field">
                                <div class="placard-label">Location</div>
                                <div class="placard-value">${artwork.repository}</div>
                            </div>

                            ${artwork.creditLine ? `
                                <div class="placard-field">
                                    <div class="placard-label">Credit</div>
                                    <div class="placard-value">${artwork.creditLine}</div>
                                </div>
                            ` : ''}

                            ${artwork.accessionNumber ? `
                                <div class="placard-field">
                                    <div class="placard-label">Accession</div>
                                    <div class="placard-value">${artwork.accessionNumber}</div>
                                </div>
                            ` : ''}

                            <a href="${artwork.sourceUrl}" target="_blank" rel="noopener noreferrer" class="placard-source" onclick="event.stopPropagation()">
                                <svg viewBox="0 0 24 24">
                                    <path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/>
                                </svg>
                                View on ${artwork.source === 'met' ? 'Met Museum' : 'Wikimedia'}
                            </a>
                        </div>
                    </div>
                </div>
            `;

            // Add click/tap handler - opens expanded view
            const tileInner = tile.querySelector('.tile-inner');

            // Track touch for distinguishing tap vs scroll
            // TAP = short duration (<300ms) + minimal movement (<10px)
            // SCROLL = any significant finger movement
            let touchStartX = 0;
            let touchStartY = 0;
            let touchStartTime = 0;

            tileInner.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchStartTime = Date.now();
                // Do NOT preventDefault - allow native scroll
            }, { passive: true });

            tileInner.addEventListener('touchend', (e) => {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const touchDuration = Date.now() - touchStartTime;

                const deltaX = Math.abs(touchEndX - touchStartX);
                const deltaY = Math.abs(touchEndY - touchStartY);

                // Only expand if it was a genuine tap:
                // - Short duration (< 300ms)
                // - Minimal movement (< 10px in any direction)
                // - Not on a button or badge
                const isTap = deltaX < 10 && deltaY < 10 && touchDuration < 300;

                if (isTap) {
                    if (!e.target.closest('.download-btn') && !e.target.closest('.save-btn') && !e.target.closest('.source-badge') && !e.target.closest('.placard-source')) {
                        openExpandedView(artwork);
                    }
                }
            }, { passive: true });

            // Desktop click handler
            tileInner.addEventListener('click', (e) => {
                // Only handle on non-touch devices
                if ('ontouchstart' in window) return;

                if (!e.target.closest('.download-btn') && !e.target.closest('.save-btn') && !e.target.closest('.source-badge') && !e.target.closest('.placard-source')) {
                    openExpandedView(artwork);
                }
            });

            const downloadBtn = tile.querySelector('.download-btn');
            downloadBtn.addEventListener('click', (e) => downloadArtwork(artwork, e, downloadBtn));

            const saveBtn = tile.querySelector('.save-btn');
            saveBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                const isSaved = saveBtn.classList.contains('saved');
                if (isSaved) {
                    const artworkId = artwork.uniqueId || artwork.id;
                    const success = await unsaveArtwork(artworkId, artwork.source);
                    if (success) saveBtn.classList.remove('saved');
                } else {
                    const success = await saveArtwork(artwork);
                    if (success) saveBtn.classList.add('saved');
                }
            });

            return tile;
        }

        // Download artwork image - uses Web Share API on mobile for Camera Roll save
        async function downloadArtwork(artwork, event, button) {
            event.stopPropagation();

            if (button.classList.contains('downloading')) return;

            // Use the highest quality image URL
            const imageUrl = artwork.imageUrl || artwork.thumbnailUrl;

            // Check device type
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            const isAndroid = /Android/i.test(navigator.userAgent);

            // iOS: Open image in new tab - user can long-press to save
            if (isIOS) {
                window.open(imageUrl, '_blank');
                showToast('Long press image to save');
                return;
            }

            // Android: Try to download directly
            if (isAndroid) {
                button.classList.add('downloading');
                try {
                    const response = await fetch(imageUrl);
                    if (!response.ok) throw new Error('Failed to fetch');

                    let blob = await response.blob();
                    let extension = 'jpg';
                    if (blob.type.includes('png')) extension = 'png';
                    else if (blob.type.includes('gif')) extension = 'gif';
                    else if (blob.type.includes('webp')) {
                        blob = await convertWebpToJpg(blob);
                    }

                    downloadBlob(blob, artwork, extension);
                    showToast('Image saved to Downloads');
                } catch (error) {
                    window.open(imageUrl, '_blank');
                    showToast('Long press image to save');
                } finally {
                    button.classList.remove('downloading');
                }
                return;
            }

            // Desktop: open image in new tab for easy right-click save
            window.open(imageUrl, '_blank');
        }

        function downloadBlob(blob, artwork, extension) {
            // Create safe filename from title and artist
            const safeTitle = (artwork.title || 'artwork').replace(/[^a-z0-9]/gi, '_').substring(0, 50);
            const safeArtist = (artwork.artist || 'unknown').replace(/[^a-z0-9]/gi, '_').substring(0, 30);
            const filename = `${safeTitle}_${safeArtist}.${extension}`;

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function convertWebpToJpg(webpBlob) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    canvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/jpeg', 0.95);
                };
                img.src = URL.createObjectURL(webpBlob);
            });
        }

        // HTML escape helper
        function escapeHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function createSkeletonTiles(count) {
            const skeletons = [];
            for (let i = 0; i < count; i++) {
                const skeleton = document.createElement('div');
                skeleton.className = 'skeleton skeleton-tile';
                skeletons.push(skeleton);
            }
            return skeletons;
        }

        function renderExploreGrid() {
            const grid = document.getElementById('exploreGrid');
            grid.innerHTML = '';
            state.exploreArtworks.forEach(artwork => {
                grid.appendChild(createTile(artwork));
            });
        }

        function renderSearchGrid() {
            const grid = document.getElementById('searchGrid');
            grid.innerHTML = '';
            state.searchArtworks.forEach(artwork => {
                grid.appendChild(createTile(artwork));
            });

            const empty = document.getElementById('searchEmpty');

            if (state.searchArtworks.length === 0 && !state.isLoading) {
                empty.style.display = 'flex';
            } else {
                empty.style.display = 'none';
            }
        }

        function renderAllGrids() {
            renderExploreGrid();
            if (state.currentTab === 'search') {
                renderSearchGrid();
            }
        }

        // ===== Art Institute of Chicago API =====
        async function fetchAICArtworks(count = 10, searchQuery = '', filters = {}) {
            if (!apiAvailability.aic) return [];

            try {
                // Fetch more when filters are active since post-filtering will discard many
                const hasFilters = filters.medium || filters.period;
                const fetchMultiplier = hasFilters ? 4 : 2;

                // Use smaller page offset for search queries to avoid going past results
                const pageNum = searchQuery
                    ? Math.floor(Math.random() * 3) + 1   // Pages 1-3 for searches
                    : Math.floor(Math.random() * 20) + 1; // Pages 1-20 for explore

                // Build search parameters
                let params = new URLSearchParams({
                    'fields': 'id,title,artist_display,date_display,date_start,date_end,medium_display,dimensions,credit_line,place_of_origin,artwork_type_title,department_title,image_id,is_public_domain,classification_title',
                    'limit': String(Math.min(count * fetchMultiplier, 50)),
                    'page': String(pageNum)
                });

                let searchTerms = [];
                if (searchQuery) {
                    // Expand user's search query with synonyms
                    const expandedTerms = getExpandedTermsArray(searchQuery);
                    searchTerms.push(...expandedTerms.slice(0, 4));
                } else {
                    // Random search term for explore mode
                    searchTerms.push(getRandomSearchTerm(usedSearchTerms, RANDOM_SEARCH_TERMS));
                }

                // Only public domain
                params.append('query[term][is_public_domain]', 'true');

                // Medium filter - don't add to search, let post-filtering handle it
                // AIC's term queries are too restrictive and case-sensitive

                // Period filtering is done via post-filtering on artwork metadata

                if (searchTerms.length > 0) {
                    params.append('q', searchTerms.join(' '));
                }

                const url = `${AIC_API_BASE}/artworks/search?${params}`;
                const cacheKey = `aic_${encodeURIComponent(url)}`;

                const data = await fetchWithBackoff(url, cacheKey);
                apiAvailability.aic = true;

                if (!data.data || data.data.length === 0) return [];

                const artworks = data.data
                    .map(obj => normalizeAICArtwork(obj, filters, searchQuery))
                    .filter(a => a !== null)
                    .sort((a, b) => {
                        // When searching, sort by relevance (higher is better)
                        if (searchQuery) {
                            const relevanceDiff = (b.searchRelevance || 0) - (a.searchRelevance || 0);
                            if (relevanceDiff !== 0) return relevanceDiff;
                        }
                        return (a.priorityScore || 50) - (b.priorityScore || 50);
                    });

                return artworks.slice(0, count);
            } catch (error) {
                console.error('AIC API failed:', error);
                apiAvailability.aic = false;
                return [];
            }
        }

        function normalizeAICArtwork(obj, filters = {}, searchQuery = '') {
            // Must have image and be public domain
            if (!obj.image_id || !obj.is_public_domain) return null;

            // Check if it's photography
            const classification = (obj.classification_title || '').toLowerCase();
            const artworkType = (obj.artwork_type_title || '').toLowerCase();
            const medium = (obj.medium_display || '').toLowerCase();

            const isPhoto = classification.includes('photograph') ||
                           artworkType.includes('photograph') ||
                           medium.includes('photograph') ||
                           medium.includes('gelatin silver') ||
                           medium.includes('albumen');

            // Exclude photography unless specifically requested
            if (isPhoto && filters.medium !== 'photographs') return null;

            // Apply medium filter if selected
            if (filters.medium && filters.medium !== '' && MEDIUM_KEYWORDS[filters.medium]) {
                // For photographs, already handled above
                if (filters.medium !== 'photographs') {
                    const hasMatch = MEDIUM_KEYWORDS[filters.medium].some(kw =>
                        medium.includes(kw) || classification.includes(kw) || artworkType.includes(kw)
                    );
                    if (!hasMatch) return null;
                }
            }

            // Apply period filter if selected
            if (filters.period && PERIOD_RANGES[filters.period]) {
                if (!matchesPeriodFilter(filters, {
                    beginYear: obj.date_start,
                    endYear: obj.date_end,
                    dateStr: obj.date_display
                })) {
                    return null;
                }
            }

            // Check search relevance before processing
            if (searchQuery && !isRelevantToSearch({
                title: obj.title,
                artist: obj.artist_display,
                classification: obj.classification_title,
                culture: obj.place_of_origin,
                period: obj.date_display
            }, searchQuery)) {
                return null;
            }

            // Calculate priority score
            let year = obj.date_end || obj.date_start;
            if (!year && obj.date_display) {
                year = extractYear(obj.date_display);
            }

            let priorityScore;
            if (!year) {
                if (isPhoto) return null; // Exclude undated photography
                priorityScore = 60 + Math.random() * 15; // Undated fine art - slight deboost
            } else if (year > 2000) {
                priorityScore = 200 + Math.random() * 100;
            } else if (year > 1980) {
                priorityScore = 100 + Math.random() * 50;
            } else if (year > 1900) {
                priorityScore = 40 + Math.random() * 20;
            } else {
                const ageFactor = Math.max(0, (1900 - year) / 100);
                priorityScore = Math.random() * 30 + Math.max(0, 10 - ageFactor * 10);
            }

            // Calculate search relevance
            const searchRelevance = calculateSearchRelevance({
                title: obj.title,
                artist: obj.artist_display,
                classification: obj.classification_title,
                culture: obj.place_of_origin,
                period: obj.date_display,
                medium: obj.medium_display,
                department: obj.department_title
            }, searchQuery);

            // Build image URL from IIIF - use bounded box format which is more reliably served
            const imageUrl = `${AIC_IMAGE_BASE}/${obj.image_id}/full/!800,800/0/default.jpg`;
            const thumbnailUrl = `${AIC_IMAGE_BASE}/${obj.image_id}/full/!400,400/0/default.jpg`;

            return {
                priorityScore,
                searchRelevance,
                uniqueId: `aic_${obj.id}`,
                source: 'aic',
                sourceUrl: `https://www.artic.edu/artworks/${obj.id}`,
                imageUrl: imageUrl,
                thumbnailUrl: thumbnailUrl,
                title: obj.title || 'Untitled',
                artist: obj.artist_display ? obj.artist_display.split('\n')[0] : 'Unknown Artist',
                artistNationality: null,
                artistDates: null,
                artistBio: null,
                date: obj.date_display || null,
                medium: obj.medium_display || null,
                dimensions: obj.dimensions || null,
                classification: obj.classification_title || null,
                department: obj.department_title || null,
                culture: null,
                period: null,
                dynasty: null,
                creditLine: obj.credit_line || null,
                geographyType: null,
                city: null,
                country: obj.place_of_origin || null,
                region: null,
                repository: 'Art Institute of Chicago',
                accessionNumber: null,
                isPublicDomain: true
            };
        }

        // ===== Cleveland Museum of Art API =====
        async function fetchClevelandArtworks(count = 10, searchQuery = '', filters = {}) {
            if (!apiAvailability.cleveland) return [];

            try {
                // Fetch more when filters are active since post-filtering will discard many
                const hasFilters = filters.medium || filters.period;
                const fetchMultiplier = hasFilters ? 4 : 2;

                // Use smaller skip for search queries to avoid going past results
                const skipOffset = searchQuery
                    ? Math.floor(Math.random() * 20)   // Small offset for searches
                    : Math.floor(Math.random() * 500); // Large offset for explore

                let params = new URLSearchParams({
                    'has_image': '1',
                    'limit': String(Math.min(count * fetchMultiplier, 50)),
                    'skip': String(skipOffset)
                });

                // Search query - expand with synonyms for better results
                if (searchQuery) {
                    const expandedTerms = getExpandedTermsArray(searchQuery);
                    params.append('q', expandedTerms.slice(0, 4).join(' '));
                } else {
                    params.append('q', getRandomSearchTerm(usedSearchTerms, RANDOM_SEARCH_TERMS));
                }

                // Medium and period filtering is done via post-filtering on artwork metadata

                const url = `${CLEVELAND_API_BASE}/artworks?${params}`;
                const cacheKey = `cleveland_${encodeURIComponent(url)}`;

                const data = await fetchWithBackoff(url, cacheKey);
                apiAvailability.cleveland = true;

                if (!data.data || data.data.length === 0) return [];

                const artworks = data.data
                    .map(obj => normalizeClevelandArtwork(obj, filters, searchQuery))
                    .filter(a => a !== null)
                    .sort((a, b) => {
                        if (searchQuery) {
                            const relevanceDiff = (b.searchRelevance || 0) - (a.searchRelevance || 0);
                            if (relevanceDiff !== 0) return relevanceDiff;
                        }
                        return (a.priorityScore || 50) - (b.priorityScore || 50);
                    });

                return artworks.slice(0, count);
            } catch (error) {
                console.error('Cleveland API failed:', error);
                apiAvailability.cleveland = false;
                return [];
            }
        }

        function normalizeClevelandArtwork(obj, filters = {}, searchQuery = '') {
            // Must have image - Cleveland uses 'images' object
            if (!obj.images || !obj.images.web || !obj.images.web.url) return null;

            // Check share license for public domain / open access
            const isOpenAccess = obj.share_license_status === 'CC0' ||
                                obj.share_license_status === 'Public Domain' ||
                                !obj.copyright;

            if (!isOpenAccess) return null;

            // Check if it's photography
            const artworkType = (obj.type || '').toLowerCase();
            const technique = (obj.technique || '').toLowerCase();
            const medium = (obj.medium || '').toLowerCase();

            const isPhoto = artworkType.includes('photograph') ||
                           technique.includes('photograph') ||
                           medium.includes('photograph') ||
                           medium.includes('gelatin silver') ||
                           medium.includes('albumen');

            // Exclude photography unless specifically requested
            if (isPhoto && filters.medium !== 'photographs') return null;

            // Apply medium filter if selected (backup for API filter)
            if (filters.medium && filters.medium !== '' && MEDIUM_KEYWORDS[filters.medium]) {
                if (filters.medium !== 'photographs') {
                    const hasMatch = MEDIUM_KEYWORDS[filters.medium].some(kw =>
                        medium.includes(kw) || technique.includes(kw) || artworkType.includes(kw)
                    );
                    if (!hasMatch) return null;
                }
            }

            // Apply period filter if selected
            if (filters.period && PERIOD_RANGES[filters.period]) {
                if (!matchesPeriodFilter(filters, {
                    beginYear: obj.creation_date_earliest,
                    endYear: obj.creation_date_latest,
                    dateStr: obj.creation_date
                })) {
                    return null;
                }
            }

            // Extract artist name for relevance check
            let artistName = 'Unknown Artist';
            if (obj.creators && obj.creators.length > 0) {
                artistName = obj.creators[0].description || obj.creators[0].name || 'Unknown Artist';
            }

            // Check search relevance before processing
            if (searchQuery && !isRelevantToSearch({
                title: obj.title,
                artist: artistName,
                classification: obj.type,
                culture: obj.culture ? obj.culture.join(' ') : '',
                period: obj.creation_date
            }, searchQuery)) {
                return null;
            }

            // Calculate priority score
            let year = null;
            if (obj.creation_date_latest) {
                year = obj.creation_date_latest;
            } else if (obj.creation_date_earliest) {
                year = obj.creation_date_earliest;
            } else if (obj.creation_date) {
                year = extractYear(obj.creation_date);
            }

            let priorityScore;
            if (!year) {
                if (isPhoto) return null; // Exclude undated photography
                priorityScore = 60 + Math.random() * 15; // Undated fine art - slight deboost
            } else if (year > 2000) {
                priorityScore = 200 + Math.random() * 100;
            } else if (year > 1980) {
                priorityScore = 100 + Math.random() * 50;
            } else if (year > 1900) {
                priorityScore = 40 + Math.random() * 20;
            } else {
                const ageFactor = Math.max(0, (1900 - year) / 100);
                priorityScore = Math.random() * 30 + Math.max(0, 10 - ageFactor * 10);
            }

            // Calculate search relevance
            const searchRelevance = calculateSearchRelevance({
                title: obj.title,
                artist: artistName,
                classification: obj.type,
                culture: obj.culture ? obj.culture.join(' ') : '',
                period: obj.creation_date,
                medium: obj.medium || obj.technique,
                department: obj.department
            }, searchQuery);

            // Cleveland provides images in different sizes - use highest available
            const imageUrl = obj.images.full?.url || obj.images.print?.url || obj.images.web.url;

            return {
                priorityScore,
                searchRelevance,
                uniqueId: `cleveland_${obj.id}`,
                source: 'cleveland',
                sourceUrl: obj.url || `https://www.clevelandart.org/art/${obj.id}`,
                imageUrl: imageUrl,
                thumbnailUrl: imageUrl,
                title: obj.title || 'Untitled',
                artist: artistName,
                artistNationality: obj.culture ? obj.culture[0] : null,
                artistDates: null,
                artistBio: null,
                date: obj.creation_date || null,
                medium: obj.medium || obj.technique || null,
                dimensions: obj.dimensions ? obj.dimensions.framed || obj.dimensions.unframed : null,
                classification: obj.type || null,
                department: obj.department || null,
                culture: obj.culture ? obj.culture.join(', ') : null,
                period: null,
                dynasty: obj.dynasty || null,
                creditLine: obj.creditline || null,
                geographyType: null,
                city: null,
                country: null,
                region: null,
                repository: 'Cleveland Museum of Art',
                accessionNumber: obj.accession_number || null,
                isPublicDomain: true
            };
        }

        // ===== Background Buffer System =====
        let bufferFetchInterval = null;
        let activeFetches = 0;
        const MAX_CONCURRENT_FETCHES = 3; // With 4 APIs we can be slightly more aggressive

        // Search buffer system
        let searchBufferFetchInterval = null;
        let activeSearchFetches = 0;

        // Start continuous background fetching
        function startBackgroundFetching() {
            // Show the buffer indicator
            updateBufferIndicator();

            // Initial fetch - staggered to avoid rate limiting
            fillExploreBuffer();
            setTimeout(() => fillExploreBuffer(), 1000);

            // Keep fetching continuously with reasonable interval
            bufferFetchInterval = setInterval(() => {
                if (state.currentTab === 'explore') {
                    const bufferSize = state.exploreBuffer.length;

                    // Only fetch if buffer is low and not already fetching
                    if (bufferSize < state.bufferTarget && activeFetches < MAX_CONCURRENT_FETCHES) {
                        fillExploreBuffer();
                    }

                    // Update indicator periodically
                    updateBufferIndicator();
                }
            }, 2000); // Check every 2 seconds to avoid overwhelming API
        }

        // Fetch artworks into the buffer (background process)
        async function fillExploreBuffer() {
            if (activeFetches >= MAX_CONCURRENT_FETCHES) return;

            activeFetches++;

            try {
                // Fetch from all available sources in parallel
                // This distributes load across APIs and reduces rate limit risk
                const fetchPromises = [];
                const countPerSource = 6; // Smaller batches from each source

                if (apiAvailability.met) {
                    fetchPromises.push(
                        fetchMetArtworks(countPerSource).catch(e => {
                            console.warn('Met API failed:', e);
                            apiAvailability.met = false;
                            return [];
                        })
                    );
                }

                if (apiAvailability.aic) {
                    fetchPromises.push(
                        fetchAICArtworks(countPerSource).catch(e => {
                            console.warn('AIC API failed:', e);
                            apiAvailability.aic = false;
                            return [];
                        })
                    );
                }

                if (apiAvailability.cleveland) {
                    fetchPromises.push(
                        fetchClevelandArtworks(countPerSource).catch(e => {
                            console.warn('Cleveland API failed:', e);
                            apiAvailability.cleveland = false;
                            return [];
                        })
                    );
                }

                if (apiAvailability.wikimedia) {
                    fetchPromises.push(
                        fetchWikimediaArtworks(countPerSource).catch(e => {
                            console.warn('Wikimedia API failed:', e);
                            apiAvailability.wikimedia = false;
                            return [];
                        })
                    );
                }

                // Wait for all fetches to complete
                const results = await Promise.all(fetchPromises);

                // Combine all results and filter duplicates
                const combined = results.flat();
                const newArtworks = combined.filter(a => a && !isDuplicate(a, state.seenIds));

                // Sort by priority (older art first) with some randomization within priority bands
                newArtworks.sort((a, b) => {
                    // Group into priority bands of 20 points
                    const scoreA = a.priorityScore || 50;
                    const scoreB = b.priorityScore || 50;
                    const bandA = Math.floor(scoreA / 20);
                    const bandB = Math.floor(scoreB / 20);
                    if (bandA !== bandB) {
                        return bandA - bandB;
                    }
                    // Within same band, randomize
                    return Math.random() - 0.5;
                });

                // Add to buffer
                state.exploreBuffer.push(...newArtworks);

                // Update visual indicator
                updateBufferIndicator();

            } catch (error) {
                console.error('Error filling buffer:', error);
            } finally {
                activeFetches--;
            }
        }

        // Stop background fetching (when switching tabs)
        function stopBackgroundFetching() {
            if (bufferFetchInterval) {
                clearInterval(bufferFetchInterval);
                bufferFetchInterval = null;
            }
            updateBufferIndicator();
        }

        // ===== Search Background Buffer System =====
        function startSearchBufferFetching() {
            if (!state.currentSearchQuery) return;

            // Show the buffer indicator
            updateBufferIndicator();

            // Initial fetch - staggered to avoid rate limiting
            fillSearchBuffer();
            setTimeout(() => fillSearchBuffer(), 1000);

            // Keep fetching continuously
            searchBufferFetchInterval = setInterval(() => {
                if (state.currentTab === 'search' && state.currentSearchQuery) {
                    const bufferSize = state.searchBuffer.length;

                    // Only fetch if buffer is low and not already fetching
                    if (bufferSize < state.bufferTarget && activeSearchFetches < MAX_CONCURRENT_FETCHES) {
                        fillSearchBuffer();
                    }

                    // Update indicator periodically
                    updateBufferIndicator();
                }
            }, 2000);
        }

        // Fetch artworks into the search buffer (background process)
        async function fillSearchBuffer() {
            if (activeSearchFetches >= MAX_CONCURRENT_FETCHES || !state.currentSearchQuery) return;

            activeSearchFetches++;

            try {
                const query = state.currentSearchQuery;
                const countPerSource = 6;

                // Always try all sources - don't skip based on availability
                // They'll recover on successful requests
                const fetchPromises = [
                    fetchMetArtworks(countPerSource, query, {}).catch(e => {
                        console.warn('Met API failed:', e);
                        return [];
                    }),
                    fetchAICArtworks(countPerSource, query, {}).catch(e => {
                        console.warn('AIC API failed:', e);
                        return [];
                    }),
                    fetchClevelandArtworks(countPerSource, query, {}).catch(e => {
                        console.warn('Cleveland API failed:', e);
                        return [];
                    }),
                    fetchWikimediaArtworks(countPerSource, query, {}).catch(e => {
                        console.warn('Wikimedia API failed:', e);
                        return [];
                    })
                ];

                const results = await Promise.all(fetchPromises);

                // Combine and filter duplicates
                const combined = results.flat();
                const newArtworks = combined.filter(a => a && !isDuplicate(a, state.searchSeenIds));

                // Shuffle for variety
                newArtworks.sort(() => Math.random() - 0.5);

                // Add to buffer
                state.searchBuffer.push(...newArtworks);

                // Update visual indicator
                updateBufferIndicator();

            } catch (error) {
                console.error('Error filling search buffer:', error);
            } finally {
                activeSearchFetches--;
            }
        }

        // Stop search buffer fetching
        function stopSearchBufferFetching() {
            if (searchBufferFetchInterval) {
                clearInterval(searchBufferFetchInterval);
                searchBufferFetchInterval = null;
            }
            updateBufferIndicator();
        }

        // Update the scroll loading indicator with phrase and buffer count
        function showScrollLoading(type = 'explore') {
            const prefix = type === 'explore' ? 'explore' : 'search';
            const scrollLoadingEl = document.getElementById(`${prefix}ScrollLoading`);
            const phraseEl = document.getElementById(`${prefix}LoadingPhrase`);
            const countEl = document.getElementById(`${prefix}ScrollCount`);
            const barFillEl = document.getElementById(`${prefix}ScrollBarFill`);

            // Set random phrase
            phraseEl.textContent = getRandomLoadingPhrase();

            // Update buffer count and bar
            const bufferSize = type === 'explore' ? state.exploreBuffer.length : state.searchBuffer.length;
            const target = state.bufferTarget;

            countEl.textContent = bufferSize;
            const fillPercent = Math.min(100, (bufferSize / target) * 100);
            barFillEl.style.width = `${fillPercent}%`;

            scrollLoadingEl.style.display = 'flex';

            // Start interval to update count while loading
            return setInterval(() => {
                const currentBuffer = type === 'explore' ? state.exploreBuffer.length : state.searchBuffer.length;
                countEl.textContent = currentBuffer;
                const currentFill = Math.min(100, (currentBuffer / target) * 100);
                barFillEl.style.width = `${currentFill}%`;
            }, 200);
        }

        function hideScrollLoading(type = 'explore', intervalId = null) {
            const prefix = type === 'explore' ? 'explore' : 'search';
            const scrollLoadingEl = document.getElementById(`${prefix}ScrollLoading`);
            scrollLoadingEl.style.display = 'none';

            if (intervalId) {
                clearInterval(intervalId);
            }
        }

        // Update the visual buffer indicator
        function updateBufferIndicator() {
            const indicator = document.getElementById('bufferIndicator');
            const countEl = document.getElementById('bufferCount');
            const fillEl = document.getElementById('bufferFill');

            // Show indicator for explore tab or search tab (when searching)
            const showForExplore = state.currentTab === 'explore';
            const showForSearch = state.currentTab === 'search' && state.currentSearchQuery;

            if (!showForExplore && !showForSearch) {
                indicator.style.display = 'none';
                return;
            }

            indicator.style.display = 'flex';

            // Get the appropriate buffer size based on current tab
            const bufferSize = state.currentTab === 'explore'
                ? state.exploreBuffer.length
                : state.searchBuffer.length;
            countEl.textContent = bufferSize;

            // Fill percentage based on target
            const fillPercent = Math.min(100, (bufferSize / state.bufferTarget) * 100);
            fillEl.style.width = `${fillPercent}%`;

            // Show fetching animation
            const isFetching = state.currentTab === 'explore' ? activeFetches > 0 : activeSearchFetches > 0;
            if (isFetching) {
                indicator.classList.add('fetching');
            } else {
                indicator.classList.remove('fetching');
            }
        }

        // ===== Loading Functions =====
        async function loadExploreArtworks(append = false) {
            const loadingEl = document.getElementById('exploreLoading');
            const scrollLoadingEl = document.getElementById('exploreScrollLoading');
            const grid = document.getElementById('exploreGrid');

            if (!append) {
                // Initial load - show loading indicator
                loadingEl.style.display = 'flex';
                grid.innerHTML = '';
                state.exploreArtworks = [];
                state.exploreBuffer = [];
                state.seenIds = new Set();

                // Fetch initial batch from all sources in parallel
                try {
                    const countPerSource = 8;

                    // Fetch from all sources in parallel for faster initial load
                    const [metArtworks, aicArtworks, clevelandArtworks, wikiArtworks] = await Promise.all([
                        fetchMetArtworks(countPerSource).catch(e => {
                            console.warn('Met API failed on initial load:', e);
                            apiAvailability.met = false;
                            return [];
                        }),
                        fetchAICArtworks(countPerSource).catch(e => {
                            console.warn('AIC API failed on initial load:', e);
                            apiAvailability.aic = false;
                            return [];
                        }),
                        fetchClevelandArtworks(countPerSource).catch(e => {
                            console.warn('Cleveland API failed on initial load:', e);
                            apiAvailability.cleveland = false;
                            return [];
                        }),
                        fetchWikimediaArtworks(countPerSource).catch(e => {
                            console.warn('Wikimedia failed on initial load:', e);
                            apiAvailability.wikimedia = false;
                            return [];
                        })
                    ]);

                    // Combine all sources, filter duplicates, and sort by priority
                    const combined = [...metArtworks, ...aicArtworks, ...clevelandArtworks, ...wikiArtworks];
                    const newArtworks = combined
                        .filter(a => a && !isDuplicate(a, state.seenIds))
                        .sort((a, b) => {
                            // Group into priority bands for some variety
                            const scoreA = a.priorityScore || 50;
                            const scoreB = b.priorityScore || 50;
                            const bandA = Math.floor(scoreA / 20);
                            const bandB = Math.floor(scoreB / 20);
                            if (bandA !== bandB) return bandA - bandB;
                            return Math.random() - 0.5;
                        });

                    state.exploreArtworks = newArtworks;
                    renderExploreGrid();

                    // If no artworks loaded, show a message
                    if (newArtworks.length === 0) {
                        showToast('Unable to load artworks. Some museum APIs may be unavailable. Please try again later.');
                    }

                    // Start background fetching to fill buffer
                    startBackgroundFetching();

                } catch (error) {
                    console.error('Error loading artworks:', error);
                    showToast('Error loading artworks. Please try again.');
                } finally {
                    loadingEl.style.display = 'none';
                }
            } else {
                // Append from buffer - this should be instant!
                if (state.exploreBuffer.length > 0) {
                    // Take items from buffer
                    const toShow = state.exploreBuffer.splice(0, state.displayBatchSize);
                    state.exploreArtworks.push(...toShow);
                    renderExploreGrid();
                } else {
                    // Buffer empty - show enhanced loading and wait for fetch
                    const updateInterval = showScrollLoading('explore');

                    // Wait for buffer to have items (with timeout)
                    let waited = 0;
                    while (state.exploreBuffer.length === 0 && waited < 5000) {
                        await new Promise(r => setTimeout(r, 200));
                        waited += 200;
                    }

                    if (state.exploreBuffer.length > 0) {
                        const toShow = state.exploreBuffer.splice(0, state.displayBatchSize);
                        state.exploreArtworks.push(...toShow);
                        renderExploreGrid();
                    }

                    hideScrollLoading('explore', updateInterval);
                }
            }

            return Promise.resolve();
        }

        async function performSearch() {
            // Stop any existing search buffer fetching
            stopSearchBufferFetching();

            const searchInput = document.getElementById('searchInput');
            const query = searchInput.value.trim();

            if (!query) return;

            // Store current search query and reset state
            state.currentSearchQuery = query;
            state.searchBuffer = [];
            state.searchSeenIds = new Set();
            state.searchArtworks = [];

            state.isLoading = true;
            const loadingEl = document.getElementById('searchLoading');
            const searchBtn = document.getElementById('searchBtn');
            const statusEl = document.getElementById('searchStatus');
            const errorEl = document.getElementById('searchError');
            const grid = document.getElementById('searchGrid');

            searchBtn.disabled = true;
            errorEl.style.display = 'none';
            loadingEl.style.display = 'flex';
            grid.innerHTML = '';
            statusEl.textContent = '';

            // Keep trying until we get results (no timeout)
            let attempts = 0;
            const maxAttempts = 10; // Will keep trying up to 10 times
            let newArtworks = [];

            while (newArtworks.length === 0 && attempts < maxAttempts && state.currentSearchQuery === query) {
                attempts++;

                try {
                    const countPerSource = 10;

                    const fetchPromises = [
                        fetchMetArtworks(countPerSource, query, {}).catch(e => {
                            console.warn('Met failed:', e);
                            return [];
                        }),
                        fetchAICArtworks(countPerSource, query, {}).catch(e => {
                            console.warn('AIC failed:', e);
                            return [];
                        }),
                        fetchClevelandArtworks(countPerSource, query, {}).catch(e => {
                            console.warn('Cleveland failed:', e);
                            return [];
                        }),
                        fetchWikimediaArtworks(countPerSource, query, {}).catch(e => {
                            console.warn('Wikimedia failed:', e);
                            return [];
                        })
                    ];

                    const results = await Promise.all(fetchPromises);

                    // Combine and filter duplicates
                    const combined = results.flat();
                    newArtworks = combined
                        .filter(a => a && !isDuplicate(a, state.searchSeenIds))
                        .sort(() => Math.random() - 0.5);

                    if (newArtworks.length === 0 && attempts < maxAttempts) {
                        // No results yet, wait a bit before retrying (loading indicator stays visible)
                        await new Promise(r => setTimeout(r, 2000));
                    }
                } catch (error) {
                    console.warn('Search attempt failed:', error);
                    if (attempts < maxAttempts) {
                        await new Promise(r => setTimeout(r, 2000));
                    }
                }
            }

            // Check if user started a different search while we were waiting
            if (state.currentSearchQuery !== query) {
                return;
            }

            state.searchArtworks = newArtworks;

            const totalResults = state.searchArtworks.length;
            if (totalResults > 0) {
                statusEl.textContent = 'Results will continue to load as we search the collections';
                // Start background buffer fetching for continuous loading
                startSearchBufferFetching();
            } else {
                // Only show this after all attempts exhausted
                statusEl.textContent = 'No results found - try a different search term';
            }

            renderSearchGrid();
            updateBufferIndicator();

            state.isLoading = false;
            loadingEl.style.display = 'none';
            searchBtn.disabled = false;
        }

        // Add more search results from buffer (called by infinite scroll)
        async function addMoreSearchResults() {
            if (!state.currentSearchQuery) return Promise.resolve();

            // If buffer has items, take from it
            if (state.searchBuffer.length > 0) {
                const toShow = state.searchBuffer.splice(0, state.displayBatchSize);
                state.searchArtworks.push(...toShow);
                renderSearchGrid();
                updateBufferIndicator();

                // Update status count
                const statusEl = document.getElementById('searchStatus');
                const totalResults = state.searchArtworks.length;
                statusEl.textContent = 'Results will continue to load as we search the collections';
            } else {
                // Buffer empty - show loading and wait for fetch
                const updateInterval = showScrollLoading('search');

                // Wait for buffer to have items (with timeout)
                let waited = 0;
                while (state.searchBuffer.length === 0 && waited < 5000) {
                    await new Promise(r => setTimeout(r, 200));
                    waited += 200;
                }

                if (state.searchBuffer.length > 0) {
                    const toShow = state.searchBuffer.splice(0, state.displayBatchSize);
                    state.searchArtworks.push(...toShow);
                    renderSearchGrid();
                    updateBufferIndicator();

                    const statusEl = document.getElementById('searchStatus');
                    const totalResults = state.searchArtworks.length;
                    statusEl.textContent = 'Results will continue to load as we search the collections';
                }

                hideScrollLoading('search', updateInterval);
            }

            return Promise.resolve();
        }

        function clearSearch() {
            stopSearchBufferFetching();
            document.getElementById('searchInput').value = '';
            document.getElementById('searchStatus').textContent = '';
            document.getElementById('searchError').style.display = 'none';
            state.searchArtworks = [];
            state.searchBuffer = [];
            state.searchSeenIds = new Set();
            state.currentSearchQuery = '';
            state.isLoading = false;
            renderSearchGrid();
            updateBufferIndicator();
        }

        // ===== Event Listeners =====
        function initEventListeners() {
            // Tab navigation
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => switchTab(btn.dataset.tab));
            });

            // Theme toggle
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);

            // Search
            document.getElementById('searchBtn').addEventListener('click', () => performSearch());
            document.getElementById('searchInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') performSearch();
            });

            // Infinite scroll
            initInfiniteScroll();
        }

        // ===== Infinite Scroll =====
        let lastScrollTop = 0;
        let isAddingMore = false;

        function initInfiniteScroll() {
            window.addEventListener('scroll', handleScroll, { passive: true });
        }

        function handleScroll() {
            const scrollTop = window.scrollY;
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight;

            // Only trigger when scrolling DOWN
            const isScrollingDown = scrollTop > lastScrollTop;
            lastScrollTop = scrollTop;

            if (!isScrollingDown) return;

            // Load more when user is within 2500px of the bottom (earlier trigger)
            const distanceFromBottom = documentHeight - (scrollTop + windowHeight);

            if (distanceFromBottom < 2500) {
                triggerLoadMore();
            }
        }

        function triggerLoadMore() {
            if (isAddingMore) return;

            if (state.currentTab === 'explore') {
                // For explore, pull from buffer (instant)
                if (state.exploreBuffer.length > 0) {
                    isAddingMore = true;
                    const toShow = state.exploreBuffer.splice(0, state.displayBatchSize);
                    state.exploreArtworks.push(...toShow);
                    renderExploreGrid();
                    updateBufferIndicator();
                    // Small delay to prevent too rapid additions
                    setTimeout(() => { isAddingMore = false; }, 100);
                } else if (activeFetches === 0) {
                    // Buffer empty and not fetching - trigger a fetch
                    fillExploreBuffer();
                }
            } else if (state.currentTab === 'search' && state.currentSearchQuery) {
                // Search tab - pull from buffer like explore
                if (state.searchBuffer.length > 0) {
                    isAddingMore = true;
                    const toShow = state.searchBuffer.splice(0, state.displayBatchSize);
                    state.searchArtworks.push(...toShow);
                    renderSearchGrid();
                    updateBufferIndicator();

                    // Update status count
                    const statusEl = document.getElementById('searchStatus');
                    const totalResults = state.searchArtworks.length;
                    statusEl.textContent = 'Results will continue to load as we search the collections';

                    setTimeout(() => { isAddingMore = false; }, 100);
                } else if (activeSearchFetches === 0) {
                    // Buffer empty and not fetching - trigger a fetch
                    fillSearchBuffer();
                }
            } else if (state.currentTab === 'foryou') {
                // For You tab - pull from buffer similar to explore
                if (state.forYouBuffer.length > 0) {
                    isAddingMore = true;
                    const toShow = state.forYouBuffer.splice(0, state.displayBatchSize);
                    state.forYouArtworks.push(...toShow);
                    renderForYouGrid();
                    // Small delay to prevent too rapid additions
                    setTimeout(() => { isAddingMore = false; }, 100);

                    // Fetch more if buffer is running low
                    if (state.forYouBuffer.length < 20) {
                        fetchMoreForYouRecommendations();
                    }
                } else if (state.forYouLoaded) {
                    // Buffer empty - fetch more explore artworks directly
                    isAddingMore = true;
                    fetchExploreArtworksForFallback(30, state.forYouSeenIds).then(artworks => {
                        if (artworks.length > 0) {
                            state.forYouBuffer.push(...artworks);
                            const toShow = state.forYouBuffer.splice(0, state.displayBatchSize);
                            state.forYouArtworks.push(...toShow);
                            renderForYouGrid();
                        }
                        setTimeout(() => { isAddingMore = false; }, 100);
                    }).catch(() => {
                        setTimeout(() => { isAddingMore = false; }, 100);
                    });
                }
            }
        }

        // ===== Initialization =====
        async function init() {
            // Clear old cache entries on startup
            clearOldCache();

            // Apply device-specific classes (touch vs no-touch)
            applyDeviceClass();

            // Re-check on window resize (device orientation change, etc.)
            window.addEventListener('resize', () => {
                applyDeviceClass();
            });

            initTheme();
            initEventListeners();
            initExpandedViewListeners();
            initTabSwipeNavigation();
            initAuth();

            // Periodically retry unavailable APIs
            setInterval(() => {
                Object.keys(apiAvailability).forEach(api => {
                    if (!apiAvailability[api]) {
                        console.log(`Retrying ${api} API availability...`);
                        apiAvailability[api] = true; // Will be set back to false if it fails again
                    }
                });
            }, 60000); // Retry every 60 seconds

            // Load initial explore content
            await loadExploreArtworks();
        }

        // Start the app
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>

